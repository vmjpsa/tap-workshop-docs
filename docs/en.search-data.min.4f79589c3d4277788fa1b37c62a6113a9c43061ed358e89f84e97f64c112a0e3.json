[{"id":0,"href":"/tap-workshop-docs/docs/module1/","title":"ワークショップ環境","section":"Docs","content":"\rワークショップ環境の概要\r#\r本ワークショップではCode Server と呼ばれるWeb サービスとし提供されるVS Code 環境を利用します。アクセスURL とパスワードに関しては講師からお伝えします。\nワークショップを提供する環境は以下のようになっています。\nTAP は既にインストール済みなので、ワークショップ参加者がTAP のインストールや構成変更をする必要はありません。参加者ごとに提供されるCode Server と名前空間の中でアプリケーションのビルドやデプロイを実施します。\nCode Server の使い方\r#\rさっそくCode Server にアクセスしてみましょう。下記のような画面が表示された場合は、Yes, I trust the authors を選択してください。\nすると下記のような画面になるはずです。 ここで、Ctrl + J キー、または下記の画像のように、ハンバーガーボタン→ Terminal → New Terminal で、ターミナルを表示させます。\n画面構成が下記のようになったら、ワークショップを進める準備は完了です。基本的なコマンド操作はターミナル上で行い、一部ファイル編集はエディタ上で行います。\n本マニュアルの使い方\r#\rマニュアルと講師の指示通り操作します。ターミナルでの操作は下記のように表現しています。右上の📋（コピーボタン）をクリックすれば、クリップボードにコマンドをコピーできます。試しにやってみましょう。\nls コマンドの貼り付けは右クリックまたはCtrl+v キーで行います。Code Server のターミナルでは右クリックができない場合がありますが、その場合はCtrl+v で行ってください。\nこの時、ブラウザでクリップボードへのアクセス許可に関する通知が出た場合は許可をしてください。\n一方で、単なるログの共有等には下記のような書き方をしていることに注意してください（コピーボタン📋はありません）。この場合はコマンドではないのでターミナルで入力する必要はないです。\ncoder@code-server-696f98d647-vx77m:~$ ls\rinstall-from-tanzunet.sh kubeconfig Code Server の使い方に慣れたら、次に進みましょう。\n"},{"id":1,"href":"/tap-workshop-docs/docs/module2/","title":"TAP の概要","section":"Docs","content":"\rTAP が求められる背景\r#\rKubernetes（K8s） はすでに世界中で利用されており、そのユーザー数は毎年どんどん増えています。日本においてもそのユーザー数は拡大しており、単なる検証フェーズではなく、本番環境での利用を進めているユーザーも増えています。それほど多くのユーザーがどんどん流入しているのは K8s 及びコンテナが有用だからなのですが、本格的に使い始めてから多くのユーザーが「K8s は難しい」という印象を抱きます。\n以下の図を見てください。 この図では K8s を比較的最近使い始めた入門ユーザーのアプリ開発からデプロイの流れ（上）と、エンタープライズ利用でのアプリ開発からデプロイまでの流れ（下）を記載しています。簡単に言ってしまうと、最初に K8s を使う場合は「アプリが動けばOK」で考えてしまうのですが、実際に大事なアプリを展開するには「バグったアプリにしない」「セキュリティ要件を満たす」「デプロイに失敗させない」などといった懸念事項が山のように出てきて、それを満たすための必要なアクションやツールがどんどん増えていきます。これは K8s 特有というよりも、従来の VM ベースの開発/運用のときと同じです。\nこの状況は K8s を使い始めた全ての組織が向き合う話ですので、これらを解決するためのツールや導入手順などが K8s の管理団体である CNCF を中心として存在しています。これらはいわゆる「Kubernetes エコシステム」と呼ばれるものです。どういったツールがあるかは「CNCF Cloud Native Interactive Landscape」にまとめられてあり、圧倒されるほどのプロジェクト数が存在しています。そして、それらを導入する手順の手引書として「CNCF Trail Map」が公開されており、かなり長い道のりが提示されています。\nこれらの道具を使って K8s の開発/運用の流れを構築するのですが、その作業も毎回人力で kubectl コマンドなどを叩くのではなく、自動化などのソリューションを利用するのが一般的です。この自動化のレベルも何段階かあり、おおよそ以下の図のレベル感となります。\n図の左が初期段階で、右に行くほど成熟してきます。一番左が自動化を全く使わずに毎回手動でコンテナをビルドして、デプロイ作業をするという段階です。K8s の基礎を学ぶだけでなく、自動化がカバーできない、たまに実施する操作や例外的な作業はマニュアルで実施します。ただ、先ほど紹介したエンタープライズな開発からデプロイまでを全てコマンドの手打ちで実施すると、面倒ですし操作ミスによるトラブルなども発生します。なにより、K8s を適切に理解している人しか、開発からデプロイまでの作業をできなくなってしまいます。\nその次のレベルがパイプラインの導入です。図にある Jenkins などが有名ですが、マニュアルで実施していた人間の作業をそのままパイプラインのスクリプトに落とし込むことで、人間が手を動かさなくても人間相当のことをパイプラインが愚直に実施してくれます。これはマニュアル作業で K8s の開発からデプロイまでを実施できるひとが、深い知識なしに手順を自動化できるという強みがあります。なぜなら、人間が打っていたコマンドラインを単にスクリプト化すればよいだけだからです。開発するアプリやパイプラインの環境が少ない場合はこれでよいかもしれません。ただ、K8s を本格的に導入しはじめると「数十のアプリを数十のパイプラインで自動化する」といった状況になってきます。こういった状況で原始的な手順ベースのパイプラインを作ってしまうと、各パイプラインの維持メンテナンスコストに悩まされます。\nそういったマニュアル作業や依存性の問題が辛くなってきたユーザーは、汎用パイプラインを卒業して多くの場合は K8s フレンドリーなツール群を使い始めます。有名なものは図にある Tekton や ArgoCD などです。たとえば Tekton によるビルドは K8s 方式の YAML 定義で実現できますし、ArgoCD によるデプロイは同様に Git リポジトリ上にある YAML 定義の構成ファイルに勝手に K8s クラスタをシンクさせるといった動きをします。Jenkins で人間の操作を自動化にそのまま落とし込むとパイプラインがフルオーダーメイドで調整しにくくなる一方、TektonやArgoCDなどはパラメーターをちょっと変更するセミオーダーメイドなので導入が簡単です。K8s のパワーユーザーはこういったツールを他にも大量に組み合わせてパイプラインを作ることが多いです。ただ、この方式にも問題があります。それは、「1つ1つの道具としては優秀なものの、それらを人間が手組みで組み合わせるという作業に辛さを覚える」という問題です。NHKの有名な教育番組のピタゴラスイッチというものがありますが、ちょうどあれを作るかのような感覚でパイプラインを組むようなものです。\nそういったユーザーが最後にたどり着くのが K8s のパイプラインフレームワークであり、VMware 製品ではこの記事で紹介する Tanzu Application Platform （TAP）となります。パイプラインフレームワークはパイプラインを構築しやすくするための仕組みであり、TAP の場合はまるでレゴでパイプラインを組み立てるかのように「フレームワークに道具を簡単にはめこめる」「道具は変更可能」ということを実現しています。こうすることで、手で調整するピタゴラスイッチなパイプラインから、ミニ四駆のような規格化されたパーツを目的に沿って組み合わせる形のパイプラインを構築できるようになります。\nTAPを導入することで、開発者はプラットフォームの些末なことを気にする必要がなくなり、アプリケーションの本質に注力することができるようになります。そして、インフラエンジニアは、開発者に対してよりよいプラットフォームを提供することを、1から100まで全て自分たちで手配する必要がなくなり、その大部分を TAP に任せることができるようになります。\nTAP の特徴\r#\rTAP の目指す世界感をおおまかにお伝えしたので、次はそれをどのように実現するかという具体的な話に移りたいと思います。まず、前提知識の話となりますが、開発者と運用者の生産性を高めるには、コンテナにしろレガシーなプラットフォームにしろ、以下のような開発/運用形態をとることが必要です。\n先にお伝えしたように、エンタープライズでのアプリケーション開発/運用は動けばよいというものではなく、セキュリティなど様々な考慮事項があり、それらの課題をクリアする必要があります。ただ、それらの課題全てを開発者が意識して開発するとなると、それはコードを書くことが本業の開発者にたいして多くを求めすぎているかもしれません。そのようなことを求めると一部の超優秀な開発者を除く8割の普通の開発者はついていけなくなります。 そういった状態になることを防ぐために、「開発者は深いことを考えずにコードを書くことに集中できる」ことと「運用者は開発者が開発したコードを、エンタープライズな要件を満たすかチェックし、満たせていれば運用に移り、満たせていなければ開発者に問題箇所を教える」ということを両立しなければいけません。このような「簡単さ」と「慎重さ」は相反するように思えるかもしれませんが、それは上記図のようにInner Loop （開発者が効率よくコードを書ける仕組み）とOuter Loop（運用者が安全にシステムを運用できる仕組み） の2本立てにすることで解決可能です。\nInner Loop は開発者本来の仕事を助けるために、「コードを書く。ビルドする。テストする」ということを短いサイクルで実現するための仕組みを提供します。コードにバグが含まれている場合などは、この短いサイクルでの開発と確認により、すでに問題箇所を特定して修復することが容易となります。\n一方、Outer Loop はさきほどのエンタープライズなパイプラインを実現するための仕組みを提供します。開発者が開発したコードが、ただ動くだけではなく、きちんとセキュリティなどの要件を満たせているかチェックし、満たせている場合は「本番環境で動いているアプリの置き換え」という一般的には重要で難しい対応をなんなく実現するための手法を提供します。\nTAPの場合は、この Inner Loop と Outer Loop を以下の図のような流れで支援しています。\nそして、この支援の裏側には以下の図のような様々なカテゴリに属するツール群が用意されています。\n本来はこれらのツール群は、k8s ユーザー自身が OSS として調達し、それらを組み合わせて目的を達成する必要があります。ただ、そのようなことを実現しようと思うと、膨大な数の検証と、アップグレードの際にちゃんと動くかテストをするといった作業負担が非常に大きいです。ただ、TAP の場合はそれらの作業を VMware がお客様の代わりに実施してあり、「このツールをフレームワークに沿って使えば動きます」という当たり前なものの実現することがなかなか大変な要件をいとも簡単に達成することができます。\nさて、実際にTAP は開発者や運用者をどのように支援できるのでしょうか？TAP の提供する機能とは具体的にどのようなものなのでしょうか？\n本ワークショップを通して、TAP を使って実際にアプリケーションの開発を体験してみることで、それらの強力な機能を学んでいきましょう！\n"},{"id":2,"href":"/tap-workshop-docs/docs/module3/","title":"Application Accelerator","section":"Docs","content":"\rApplication Accelerator\r#\r今回は、アプリケーション開発者であるあなたのストーリーを基にラボを進めます。あなたの会社では現在 Tanzu Application Platform が稼働しており、あなたはこのプラットフォームを使ってコンテナ化したアプリケーションの配信をしたいと考えています。\nあなたは、コンテナインフラストラクチャの専門家ではありません。あくまで開発者であり、人気のある言語やフレームワークを使ってビジネスアプリケーションを書くことに関しての専門家です。\nあなたは、開発プロジェクトを容易に始めるためのテンプレートを必要としています。あなたは、開発プロジェクトの編集やビルド、実行に必要なすべてのコンポーネントを含む、厳選されたテンプレートをダウンロードしたいと思っています。そのようなテンプレートがあればオンボーディングがシンプルだからです。\nまた、あなたはDockerfile、Kubernetesリソース、およびその他のインフラストラクチャのアーティファクトを自分で記述し、維持する責任をなるべく負いたくありません。このようなインフラストラクチャの準備や運用によって、開発者はアプリケーションロジックを書いたり、ストーリーを提供したりする時間が少なくなってしまいます。\nこのような開発者の要望に対して、Tanzu Application Platform では、あなたが会社で使用が承認されたテンプレートを閲覧し、利用するための簡単な方法を提供します。これは Application Accelerator と呼ばれ、Tanzu Application Platform の Web インターフェース（TAP GUI）でホストされています。\nエンタープライズアーキテクトはApplication Accelerator を使って、組織内の開発者にコードや設定のためのエンタープライズに準拠したテンプレートを提供します。開発者はApplication Accelerator を使用して、企業標準に準拠したプロジェクトを作成したり、それにアクセスしたりできます。\nさて、さっそくApplication Accelerator を確認してみましょう。 TAPGUI のURL は下記コマンドで確認することができます。新しいブラウザタブを開いてTAP GUIにアクセスします。左上の\u0026raquo; をクリックし、Create を選択します。\necho $TAP_GUI_URL これで、あなたは自分が取り組みたいプログラミング言語(Java やNodeなど)とアプリケーションの種類（Web, メッセージ駆動型, 関数など）に適したテンプレートを見つけることができます。\nAccelerator Templates\r#\rTanzu Java Web App テンプレートで作業してみましょう。Tanzu Java Web App のタイルにある choose ボタンを押します。UI でプロジェクトテンプレートをカスタマイズするためのオプションパラメータが提供されていますが、デフォルトのままNextを押してください。選択した内容を確認するプロンプトが表示されるので、Generate Acceleratorをクリックします。\nその後、EXPLORE ZIP FILE をクリックして、テンプレートフォルダの中身を見てみましょう。\nファイルを見てみると、Java やSpring を知っている方であればおなじみのディレクトリ構造を確認できます。あなたがスターターアプリケーションで使用するソースコードファイルと、Tanzu Application Platform でアプリケーションを操作するためのいくつかの追加のファイルで構成されていることがわかります。これらの追加ファイルについては後のセクションで詳しく見ていきます。確認が終了したら右下のCLOSE をクリックして終了します。\nこのテンプレートはtanzu CLI でもダウンロードできます。\rここではこのテンプレートは使用しないので、ファイルをダウンロードする必要はありません。\r"},{"id":3,"href":"/tap-workshop-docs/docs/module4/","title":"Live Update","section":"Docs","content":"\rLive Update\r#\rApplication Accelerator では、Web UI を使用して、プロジェクトテンプレートを .zip ファイルとしてローカルマシンにダウンロードすることができます。今回は、このようなテンプレートがgit 上でホストされているケースを想定し、皆さんがおなじみのgit コマンドを使ってテンプレートをダウンロードし、アプリケーションの開発を開始します。\nさっそくテンプレートをダウンロードしましょう。\ngit clone https://github.com/vmjpsa/node-hello-tanzu.git cd node-hello-tanzu 今回はHello Tanzu! と画面に表示するだけの非常に単純なWeb アプリケーションで、アプリケーション開発を試してみます。\nTAP ではLive Update と呼ばれる便利な機能を提供しています。Live Update では、Tilt の機能を活用して、より高速な反復開発を実現することができます。フォルダの中にTiltfile_sample というファイルがあることに注目してください。Tiltfile は Application Accelerator によってプロジェクトテンプレートの一部として作られたファイルです。Tiltfile スクリプトは、Tanzu Application Platform を利用して、3つの主要なタスクを実行します。\nコンテナイメージの作成 アプリケーションの実行と、アプリケーションへアクセスするための Kubernetes リソースを作成 ソースコードの編集に伴うアプリケーションのLive Update を有効にする これらの各ステップを詳しく見ていきましょう。\nコンテナイメージの作成\r#\rTanzu Application Plaform の最も強力な機能の1つは、Tanzu Build Service です。これは開発者が提供するアプリケーションのソースコードからランタイムコンテナを自動生成します。これらのコンテナイメージを作成するために、CNCFプロジェクトのCloud Native Buildpacksを活用しています。Tanzu は、最新の言語ランタイムの依存性を提供しながら、セキュリティとパフォーマンスのためにコンテナイメージを最適化するためのビルドパックを提供します。Tanzu のビルドパックは、Java、.NET Core、Node、Go、Python、PHPなど、最も一般的なプログラミング言語に対応しています。また、その他の言語のニーズがある場合は、オープンソースコミュニティが他の多くの言語用のビルドパックを提供しています。\n開発者のあなたは、Tanzu Build Service のメリットを活用することで、自分で Dockerfile を作成したり、メンテナンスしたりする必要がなく、コンテナの安全性やパッチの適用を保証するための作業に追われることもなくなります。あなたは、コンテナランタイムの生成ではなく、ソースコードを書く本来の作業に集中することができます。\nKubernetes リソースの作成\r#\r開発環境が Kubernetes クラスタの場合、Tanzu Application Platform はコンテナイメージをデプロイ・実行するために必要な Kubernetes リソースを作成し、ローカルマシンから Kubernetes にデプロイされたアプリケーションにアクセスできるようにします。この環境では、Tanzu Application Platform に組み込まれているオープンソースプロジェクト Knative をランタイムに使用しています。\nLive Update\r#\rTilt では、開発環境にアプリケーションをデプロイするもので、初回実行時には完了まで数分かかりますが、次回以降の時間は短縮されるため、実行中のアプリケーションを数秒で更新することができます。どのように動作するか見てみましょう。\nまずは、自身の環境から、作成したコンテナイメージをプッシュできるようにコンテナレジストリにログインをします。\ndocker login $REPO_URL -u $REPO_USER -p $REPO_PASSWORD 警告は出ますがLogin Succeeded と出ればOK です。\ncoder@code-server-696f98d647-vx77m:~$ docker login $REPO_URL -u $REPO_USER -p $REPO_PASSWORD\rWARNING! Using --password via the CLI is insecure. Use --password-stdin.\rWARNING! Your password will be stored unencrypted in /home/coder/.docker/config.json.\rConfigure a credential helper to remove this warning. See\rhttps://docs.docker.com/engine/reference/commandline/login/#credentials-store\rLogin Succeeded 次に、Tiltfile を作成します。先にみたように、本来Tiltfile はテンプレートに含むべきですが、このワークショップでは環境の都合上ユーザーごとにTiltfile を編集する必要があるため、下記コマンドで作成します。少し長い入力ですが、実行しているのはTiltfile_sample をベースとしたTiltfile の作成です。\ncat \u0026lt;\u0026lt;EOF \u0026gt; Tiltfile SOURCE_IMAGE = os.getenv(\u0026#34;SOURCE_IMAGE\u0026#34;, default=\u0026#39;${REPO_URL}/tap-workshop/node-hello-tanzu-${SESSION_NUMBER}\u0026#39;) # REPO_URL like harbor.tanzu.lab/tap-workshop/node-hello-tanzu LOCAL_PATH = os.getenv(\u0026#34;LOCAL_PATH\u0026#34;, default=\u0026#39;.\u0026#39;) NAMESPACE = os.getenv(\u0026#34;NAMESPACE\u0026#34;, default=\u0026#39;\u0026#39;) K8S_TEST_CONTEXT = os.getenv(\u0026#34;K8S_TEST_CONTEXT\u0026#34;, default=\u0026#39;\u0026#39;) allow_k8s_contexts(K8S_TEST_CONTEXT) k8s_custom_deploy( \u0026#39;node-hello-tanzu\u0026#39;, apply_cmd=\u0026#34;tanzu apps workload apply -f config/workload.yaml --live-update\u0026#34; + \u0026#34; --local-path \u0026#34; + LOCAL_PATH + \u0026#34; --source-image \u0026#34; + SOURCE_IMAGE + \u0026#34; --namespace \u0026#34; + NAMESPACE + \u0026#34; --yes \u0026gt;/dev/null\u0026#34; + \u0026#34; \u0026amp;\u0026amp; kubectl get workload node-hello-tanzu --namespace \u0026#34; + NAMESPACE + \u0026#34; -o yaml\u0026#34;, delete_cmd=\u0026#34;tanzu apps workload delete -f config/workload.yaml --namespace \u0026#34; + NAMESPACE + \u0026#34; --yes\u0026#34; , deps=[\u0026#39;.\u0026#39;], container_selector=\u0026#39;workload\u0026#39;, live_update=[ fall_back_on([\u0026#39;package.json\u0026#39;]), sync(\u0026#39;.\u0026#39;, \u0026#39;/workspace\u0026#39;) ] ) k8s_resource(\u0026#39;node-hello-tanzu\u0026#39;, port_forwards=[\u0026#34;8080:8080\u0026#34;], extra_pod_selectors=[{\u0026#39;carto.run/workload-name\u0026#39;: \u0026#39;node-hello-tanzu\u0026#39;, \u0026#39;app.kubernetes.io/component\u0026#39;: \u0026#39;run\u0026#39;}]) allow_k8s_contexts(\u0026#39;${CLUSTER_NAME}\u0026#39;) EOF Tiltfile ができたら、いよいよLive Update の機能を試します。下記のtanzu コマンドを入力します。このコマンドではgit clone したローカルのファイルをベースにワークロードの作成の準備をします。\ntanzu apps workload apply node-hello-tanzu --live-update --local-path . -s $REPO_URL/tap-workshop/node-hello-tanzu-${SESSION_NUMBER} -y 下記のようなログが出力されるはずです。\nPublishing source in \u0026#34;.\u0026#34; to \u0026#34;$REPO_URL/tap-workshop/node-hello-tanzu-${SESSION_NUMBER}\u0026#34;...\rPublished source\rCreate workload:\r1 + |---\r2 + |apiVersion: carto.run/v1alpha1\r3 + |kind: Workload\r4 + |metadata:\r5 + | name: node-hello-tanzu\r6 + | namespace: tap-workshop-01\r7 + |spec:\r8 + | source:\r9 + | image: $REPO_URL/tap-workshop/node-hello-tanzu-${SESSION_NUMBER}:latest@sha256:abcdef... tanzu コマンド入力後、tilt up でワークロードがデプロイされます。\ntilt up --stream ログは下記のように出力されます。先述したように、初回のビルドは少し時間がかかります。\ncoder@code-server-696f98d647-vx77m:~/node-hello-tanzu$ tilt up\rTilt started on http://localhost:10350/\rv0.30.11, built 2022-11-07\rInitial Build\rLoading Tiltfile at: /home/coder/node-hello-tanzu/Tiltfile\rSuccessfully loaded Tiltfile (1.415443ms)\rERROR: [] \u0026#34;msg\u0026#34;=\u0026#34;Reconciler error\u0026#34; \u0026#34;error\u0026#34;=\u0026#34;Failed to update API server: create configmaps/node-hello-tanzu-disable: configmaps.tilt.dev \\\u0026#34;node-hello-tanzu-disable\\\u0026#34; already exists\u0026#34; \u0026#34;controller\u0026#34;=\u0026#34;tiltfile\u0026#34; \u0026#34;controllerGroup\u0026#34;=\u0026#34;tilt.dev\u0026#34; \u0026#34;controllerKind\u0026#34;=\u0026#34;Tiltfile\u0026#34; \u0026#34;Tiltfile\u0026#34;={\u0026#34;name\u0026#34;:\u0026#34;(Tiltfile)\u0026#34;} \u0026#34;namespace\u0026#34;=\u0026#34;\u0026#34; \u0026#34;name\u0026#34;=\u0026#34;(Tiltfile)\u0026#34; \u0026#34;reconcileID\u0026#34;=\u0026#34;caf681ca-5e03-4d6f-9e76-c6e0468da938\u0026#34;\rWARNING: Writing Kubernetes config: could not create any of the following paths: /run/user/1000/tilt-dev/tilt-default/cluster\rnode-hello-t… │ node-hello-t… │ Initial Build\rnode-hello-t… │ STEP 1/1 — Deploying\rnode-hello-t… │ Running cmd: tanzu apps workload apply -f config/workload.yaml --live-update --local-path . --source-image $REPO_URL/tap-workshop/node-hello-tanzu-01 --namespace tap-workshop-01 --yes \u0026gt;/dev/null \u0026amp;\u0026amp; kubectl get workload node-hello-tanzu --namespace tap-workshop-01 -o yaml\rnode-hello-t… │ Objects applied to cluster:\rnode-hello-t… │ → node-hello-tanzu:workload\rnode-hello-t… │ node-hello-t… │ Step 1 - 1.88s (Deploying)\rnode-hello-t… │ DONE IN: 1.88s node-hello-t… │ node-hello-t… │ node-hello-t… │ Tracking new pod rollout (node-hello-tanzu-00001-deployment-66df8f56b6-2bp5q):\rnode-hello-t… │ ┊ Scheduled - \u0026lt;1s\rnode-hello-t… │ ┊ Initialized - (…) Pending\rnode-hello-t… │ ┊ Ready - (…) Pending\rnode-hello-t… │ [queue-proxy] {\u0026#34;severity\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2022-12-05T11:37:01.427999526Z\u0026#34;,\u0026#34;logger\u0026#34;:\u0026#34;queueproxy\u0026#34;,\u0026#34;caller\u0026#34;:\u0026#34;queue/main.go:197\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Starting queue-proxy\u0026#34;,\u0026#34;commit\u0026#34;:\u0026#34;3666ce7\u0026#34;,\u0026#34;knative.dev/key\u0026#34;:\u0026#34;tap-workshop-01/node-hello-tanzu-00001\u0026#34;,\u0026#34;knative.dev/pod\u0026#34;:\u0026#34;node-hello-tanzu-00001-deployment-66df8f56b6-2bp5q\u0026#34;} デプロイが完了したら、アプリケーションにアクセスしてみましょう。アプリケーションは今Kubernetes 上にデプロイされていますが、下記スクリーンショットのように、Code Server ポートフォワーディングの機能でローカル端末からアクセスできます。\nCtrl + クリック、またはURL を直接コピーし、別タブでアクセスします。このタブは開いたままにします。\n次に、アプリケーションのコードの中心であるindex.js ファイルを開き、Hello Tanzu! をHello Tanzu!!! などと任意に変更してみてください。\nすると、tilt の出力が下記のように更新されるはずです。\n......\rnode-hello-t… │ 1 File Changed: [index.js]\rnode-hello-t… │ Will copy 1 file(s) to container: [node-hello-tanzu-00002-deployment-5ffd767b87-78m56/workload]\rnode-hello-t… │ - \u0026#39;/home/coder/node-hello-tanzu/index.js\u0026#39; --\u0026gt; \u0026#39;/workspace/index.js\u0026#39;\rnode-hello-t… │ → Container node-hello-tanzu-00002-deployment-5ffd767b87-78m56/workload updated! 再びアプリケーションのタブを確認し、画面を更新すると、上記の変更が即座に反映されているはずです。\nターミナルにてCtrl+C を入力し、LiveUpdate を中断しましょう。\n今回は単純なNodeJS のアプリでしたが、例えばSpring （Java） のアプリ等でも同様な機能を利用することができます。この際、Dockerfile はどこにも登場しなかったことに注意してください。TAP のコンポーネントであるTanzu Build Service によって、自動的にNodeJS のアプリと判定され、ベストプラクティスに沿った形でコンテナ化され、それがKubernetes 上に展開されています。開発者としては、アプリケーションの本質的な部分により時間を割くことができます。\nまた、今回はLive Update を利用するためにtanzu とtilt の2 つのコマンドを使いましたが、TAP ではVS Code やIntelliJ といったエディタの拡張機能としてもLive Update の機能を提供しており、これらのコマンドを入力することなく利用することができます（今回はラボの制約のためCLI 入力としました）。\nこれでLive Update の機能を確認できましたので、Tilt で作成したアプリケーションを削除しましょう。\ntanzu apps workload delete node-hello-tanzu -y また、ログでターミナルが汚れていると思いますので、確認し終わったらclear してしまいましょう。\nclear "},{"id":4,"href":"/tap-workshop-docs/docs/module5/","title":"Git を使ったデプロイ","section":"Docs","content":"\rGit とは\r#\rGit はいわゆる分散型バージョン管理システムです。アプリケーションのソースコードを適切にバージョン管理したり、変更を追跡したりするための仕組みの1 つです。また、その分散型という仕組みから、それぞれの開発者がローカルリポジトリで開発を進め、変更を確定（コミット）し、その変更点をリモートリポジトリ（例えばGithub）に送信（プッシュ）するという開発形態をとることができ、チーム開発において様々なメリットを提供します。\nGit を使ったデプロイ\r#\rさて、先ほどはLive Update の機能でアプリケーションをデプロイしました。これは個人で開発を進めるためには強力な機能ですが、チームで開発する場合はやはりGit のリモートリポジトリを活用したいです。そこで、今回はGit のリモートリポジトリへのコミットをトリガとしてアプリケーションのデプロイをしてみましょう。\nまず、現時点でカレントディレクトリはnode-hello-tanzu のはずですが、そうでない場合は下記コマンドでカレントディレクトリを変更してください。\ncd $HOME/node-hello-tanzu 次にgit の設定をします。ユーザーのメールアドレスと名前を下記コマンドで設定しますが、特に指定はないため何でも構いません（下記はサンプルです）。ご自身のe-mail アドレスを入力する必要はございません。\ngit config --global user.email tap-workshop@test.lab git config --global user.name tap-workshop 先のLive Update で、index.js の「Hello, Tanzu!」を「Hello, Tanzu!!!」等に書き換えました。そこでこの変更をローカルリポジトリにコミットします（「Hello, Tanzu!」のままだと変更がないとみなされるため、git add の前に任意に変更してください）。\ngit add -A git commit -m \u0026#34;My first commit!\u0026#34; 変更をリモートリポジトリにプッシュします。\ngit push https://$GIT_USER:$GIT_PASSWORD@$GIT_URL/tap-workshop/node-hello-tanzu-$SESSION_NUMBER main これで準備ができたので、下記コマンドでアプリケーションをデプロイしましょう。\ntanzu apps workload create node-hello-tanzu --git-repo https://$GIT_URL/tap-workshop/node-hello-tanzu-$SESSION_NUMBER.git --git-branch main --label app.kubernetes.io/part-of=tanzu-node-hello-tanzu --type web --annotation autoscaling.knative.dev/minScale=1 -y このコマンドは少々複雑ですが、オプションとしてgit リポジトリやブランチなどを指定しています。 \u0026ndash;annotation autoscaling.knative.dev/minScale=1 の意味は、Knative Serving の最小インスタンス数を1 以上に設定し、時間経過でPod の数が0 になることを防止しています。\n\u0026ndash;type web はワークロードの種類になります。TAP1.3 ではweb, server, worker タイプをサポートしています。詳細は下記ドキュメントをご参照ください。\nhttps://docs.vmware.com/en/VMware-Tanzu-Application-Platform/1.3/tap/GUID-workloads-workload-types.html\ntanzu コマンドの結果として、下記のようなログが出力されるはずです。\ncoder@code-server-69dd88bff7-d9x22:~/node-hello-tanzu$ tanzu apps workload create node-hello-tanzu --git-repo https://$GIT_URL/tap-workshop/node-hello-tanzu-$SESSION_NUMBER.git --git-branch main --label app.kubernetes.io/part-of=tanzu-node-hello-tanzu --type web --annotation autoscaling.knative.dev/minScale=1 -y\rCreate workload:\r1 + |---\r2 + |apiVersion: carto.run/v1alpha1\r3 + |kind: Workload\r4 + |metadata:\r5 + | labels:\r6 + | app.kubernetes.io/part-of: tanzu-node-hello-tanzu\r7 + | apps.tanzu.vmware.com/workload-type: web\r8 + | name: node-hello-tanzu\r9 + | namespace: tap-workshop-01\r10 + |spec:\r11 + | params:\r12 + | - name: annotations\r13 + | value:\r14 + | autoscaling.knative.dev/minScale: \u0026#34;1\u0026#34;\r15 + | source:\r16 + | git:\r17 + | ref:\r18 + | branch: main\r19 + | url: https://$GIT_URL/tap-workshop/node-hello-tanzu-01.git\rCreated workload \u0026#34;node-hello-tanzu\u0026#34;\rTo see logs: \u0026#34;tanzu apps workload tail node-hello-tanzu\u0026#34;\rTo get status: \u0026#34;tanzu apps workload get node-hello-tanzu\u0026#34; 指示通り、デプロイの状態を確認してみましょう。\ntanzu apps workload get node-hello-tanzu coder@code-server-696f98d647-vx77m:~/node-hello-tanzu$ tanzu apps workload get node-hello-tanzu\r📡 Overview\rname: node-hello-tanzu\rtype: web\r💾 Source\rtype: git\rurl: https://$GIT_URL/tap-workshop/node-hello-tanzu-01.git\rbranch: main\r📦 Supply Chain\rname: source-to-url\rRESOURCE READY HEALTHY TIME OUTPUT\rsource-provider Unknown Unknown 3s GitRepository/node-hello-tanzu\rimage-provider False Unknown 3s not found\rconfig-provider False Unknown 3s not found\rapp-config False True 3s not found\rservice-bindings False True 3s not found\rapi-descriptors False True 3s not found\rconfig-writer False Unknown 3s not found\r🚚 Delivery\rDelivery resources not found.\r💬 Messages\rWorkload [MissingValueAtPath]: waiting to read value [.status.artifact.url] from resource [gitrepository.source.toolkit.fluxcd.io/node-hello-tanzu] in namespace [tap-workshop-01]\rWorkload [HealthyConditionRule]: condition with type [Ready] not found on resource status\r🛶 Pods\rNAME READY STATUS RESTARTS AGE\rnode-hello-tanzu-build-1-build-pod 0/1 Pending 0 0s\rTo see logs: \u0026#34;tanzu apps workload tail node-hello-tanzu\u0026#34; デプロイが完了するまでしばらく待ちましょう。下記コマンドでデプロイまでのログを確認できます（中断はCtrl+c）。\ntanzu apps workload tail node-hello-tanzu アプリケーションのデプロイが完了すると、下記のように表示されますので、🚢 Knative Services の欄で出力されたURL にアクセスするとLive Update と同様index.js の文字列が出力されるはずです（URL をCtrl+クリックで別タブで開くことができます）。\ncoder@code-server-696f98d647-vx77m:~/node-hello-tanzu$ tanzu apps workload get node-hello-tanzu\r📡 Overview\rname: node-hello-tanzu\rtype: web\r💾 Source\rtype: git\rurl: https://$GIT_URL/tap-workshop/node-hello-tanzu-01.git\rbranch: main\r📦 Supply Chain\rname: source-to-url\rRESOURCE READY HEALTHY TIME OUTPUT\rsource-provider True True 83s GitRepository/node-hello-tanzu\rimage-provider True True 63s Image/node-hello-tanzu\rconfig-provider True True 56s PodIntent/node-hello-tanzu\rapp-config True True 56s ConfigMap/node-hello-tanzu\rservice-bindings True True 56s ConfigMap/node-hello-tanzu-with-claims\rapi-descriptors True True 56s ConfigMap/node-hello-tanzu-with-api-descriptors\rconfig-writer True True 49s Runnable/node-hello-tanzu-config-writer\r🚚 Delivery\rname: delivery-basic\rRESOURCE READY HEALTHY TIME OUTPUT\rsource-provider True True 23s ImageRepository/node-hello-tanzu-delivery\rdeployer True True 16s App/node-hello-tanzu\r💬 Messages\rNo messages found.\r🛶 Pods\rNAME READY STATUS RESTARTS AGE\rnode-hello-tanzu-00001-deployment-54bcc768bb-sgrnp 2/2 Running 0 23s\rnode-hello-tanzu-build-1-build-pod 0/1 Completed 0 87s\rnode-hello-tanzu-config-writer-ts27k-pod 0/1 Completed 0 57s\r🚢 Knative Services\rNAME READY URL\rnode-hello-tanzu Ready http://node-hello-tanzu.tap-workshop-01.***\rTo see logs: \u0026#34;tanzu apps workload tail node-hello-tanzu\u0026#34; アプリケーションのデプロイが確認出来たら、ソースコードを変更してみます。index.js の「Hello Tanzu!!!」を「Hello Git Tanzu!!!」と変更します（Code Server 上でのファイルの変更は自動で保存されるためCtrl+s などは必要ありません）。\nここでは、Live Update と異なりアプリケーションの更新は発生しません。先ほどのtanzu apps workload create コマンドでは、リモートリポジトリへの変更を追跡し、その変更をトリガに再ビルドをさせようとしていますので、再びコードをコミットし、リモートリポジトリにプッシュします。\ngit add -A git commit -m \u0026#34;My Second commit!\u0026#34; git push https://$GIT_USER:$GIT_PASSWORD@$GIT_URL/tap-workshop/node-hello-tanzu-$SESSION_NUMBER main 変更が反映されるまでしばらく待ってください。下記コマンドでアプリケーションの再ビルドが走ることを追跡することもできます。\ntanzu apps workload get node-hello-tanzu tanzu apps workload tail node-hello-tanzu 先と同じように、アプリケーションのURL が発行されたらアクセスし、表示が「Hello Git Tanzu!!!」に変わっていることを確認します。\n"},{"id":5,"href":"/tap-workshop-docs/docs/module6/","title":"ソフトウェアサプライチェーン","section":"Docs","content":"\rソフトウェアサプライチェーン\r#\r先ほどLive Update でアプリケーションをデプロイしましたが、先述したようにコードを書いてURL として公開される、いわゆるSource to URL の世界のその間に実際に多くのプロセスが含まれます。それを確認してみましょう。\nTAP GUI にアクセスします。別タブで開いていない場合は下記コマンドでURL を確認できますので再度アクセスしてください。\necho $TAP_GUI_URL アクセスしたら、下記画像のように、左ペインの十字のようなアイコンをクリックします。nohe-hello-tanzu という項目がありますのでそれをクリックします。なお、他の参加者のアプリケーションもここでは見えるため、node-hello-tanzu が沢山あるかもしれませんが、どれを選択しても構いません。\nここで、アプリケーションがどのようなプロセスを経てURL として公開されたかが分かります。\nサプライチェーンとは？\r#\rサプライチェーンは確認できましたか？今回はsource-to-url というTAP 組み込みの最もシンプルなサプライチェーンを使ってデプロイされています。このサプライチェーンは、その名の通りソースコードを入力として、最終的にURL として公開しているのですが、間にいくつかステップがあります。例えばImage Builder ではソースコードからTanzu Build Service を使ってコンテナイメージを作成するステップになります。Config Provider はConvention Services と呼ばれる仕組みで、サプライチェーンの中で推奨設定値をマニフェストに埋め込むことができます。App Config ステップでは、Knativeサービング、サービスバインディング、リソースクレーム、Kubernetes のConfigmap を作成します。Config Writer ステップでは追加の設定ファイルをイメージのレポジトリやgit リポジトリに作成します。Pull Config は設定値の取得、そして最後にDelivery ステップで作成したアプリケーションがKubernetes 上にknative オブジェクトとして展開され、URL としてアクセスできるようになります。\n一般的なCI/CD パイプラインとの違いは何でしょうか？\nサプライチェーンは、CI/CD パイプラインを含む、より一般的な単語です。つまり、ソフトウェアがユーザーに届けられるまでの一連の流れを表現したもので、Cartographer というTAP の中核的なコンポーネントで実現されます。TAP では、Cartographer を用いて、Tekton などのCI/CD パイプラインを実現するソフトウェアをさらに抽象化しています。抽象化といえばサーバー仮想化も一つの抽象化ですが、ここでの抽象化の大きなメリットは複雑化しているCI/CD にシンプルさを提供することです。DevSecOps を実現するには、開発者やインフラ担当、セキュリティ担当など、様々な役割を持った人が相互に連携しなければなりません。既存のCI/CD パイプラインでは、線形にタスクを連結し、ある種のオレオレパイプラインが出来上がり、結果属人化やメンテナンスコストの問題が発生する可能性があります。\nCatographer では、サプライチェーン作成時にインプットとアウトプットに注目します。つまり、何を受け取り、何を出力するのかさえ正しく記述していれば、そのステップ（Cartographer ではテンプレートと呼びます）で何が起ころうとも気にしません。GUI 上でステップ間に小さな四角とその中の文字列があったかと思いますが、あれがまさにインプットでありアウトプットです。例えば、最初のSource Provicer ステップの出力はtar.gz に固めたソースファイルのURL とリビジョン、およびそれぞれのダイジェスト値ですし、Image Builder のインプットもそれらになります。サプライチェーンを作成する側からしてみれば考慮事項が減るため、よりシンプルに役割分担ができると言えます。\nまた、抽象化の大きな恩恵でもある柔軟性のメリットもあります。複数のアプリケーションにまたがるサプライチェーンの再利用や、コードのコミット（セキュリティ スキャン、CVE パッチ適用、OS パッチ適用など）に依存しないトリガの柔軟性が向上します。\n他にもサプライチェーンを利用するメリットは多々ありますが、詳細はhttps://blogs.vmware.com/vmware-japan/2022/09/beyond_ci_cd.htmlをご参照ください。\n重要な点として、サプライチェーンはCI/CD パイプラインを補完するものであり、対立するものでは決してありません。既存のCI/CD パイプラインが、もし運用性や属人化等の課題を抱えているのであれば、Catographer やTAP が支援できるかもしれません。\nさて、TAP の場合は組み込みの典型的なサプライチェーンがいくつか用意されています。もう少しTAP の機能を深堀りしてみるために、別のサプライチェーンを使ってアプリケーションをデプロイしてみましょう。\n次に進む前に、デプロイしたnode-hello-tanzu アプリケーションを削除します。\ntanzu apps workload delete node-hello-tanzu -y coder@code-server-696f98d647-vx77m:~/node-hello-tanzu$ tanzu apps workload delete node-hello-tanzu -y\rDeleted workload \u0026#34;node-hello-tanzu\u0026#34; "},{"id":6,"href":"/tap-workshop-docs/docs/module7/","title":"セキュアなソフトウェアサプライチェーン","section":"Docs","content":"\rセキュアなソフトウェアサプライチェーン\r#\rnode-hello-tanzu と同様、リモートリポジトリにあるファイルを入力値として、tanzu コマンドでtanzu-java-web-app アプリケーションをデプロイします。これはJava Spring アプリケーションです。\ntanzu apps workload create tanzu-java-web-app --git-repo https://github.com/vmware-tanzu/application-accelerator-samples --sub-path tanzu-java-web-app --git-branch main --type web --label apps.tanzu.vmware.com/has-tests=true --label app.kubernetes.io/part-of=tanzu-java-web-app --annotation autoscaling.knative.dev/minScale=1 -y coder@code-server-696f98d647-vx77m:~/node-hello-tanzu$ tanzu apps workload create tanzu-java-web-app --git-repo https://github.com/vmware-tanzu/application-accelerator-samples --sub-path tanzu-java-web-app --git-branch main --type web --label apps.tanzu.vmware.com/has-tests=true --label app.kubernetes.io/part-of=tanzu-java-web-app --annotation autoscaling.knative.dev/minScale=1 -y\rCreate workload:\r1 + |---\r2 + |apiVersion: carto.run/v1alpha1\r3 + |kind: Workload\r4 + |metadata:\r5 + | labels:\r6 + | app.kubernetes.io/part-of: tanzu-java-web-app\r7 + | apps.tanzu.vmware.com/has-tests: \u0026#34;true\u0026#34;\r8 + | apps.tanzu.vmware.com/workload-type: web\r9 + | name: tanzu-java-web-app\r10 + | namespace: tap-workshop-01\r11 + |spec:\r12 + | params:\r13 + | - name: annotations\r14 + | value:\r15 + | autoscaling.knative.dev/minScale: \u0026#34;1\u0026#34;\r16 + | source:\r17 + | git:\r18 + | ref:\r19 + | branch: main\r20 + | url: https://github.com/vmware-tanzu/application-accelerator-samples\r21 + | subPath: tanzu-java-web-app\rCreated workload \u0026#34;tanzu-java-web-app\u0026#34;\rTo see logs: \u0026#34;tanzu apps workload tail tanzu-java-web-app\u0026#34;\rTo get status: \u0026#34;tanzu apps workload get tanzu-java-web-app\u0026#34; node-hello-tanzu をデプロイした時とコマンドが似ていますが、ここで最も重要なのは、\u0026ndash;label apps.tanzu.vmware.com/has-tests=true オプションです。これは単なるラベルにすぎませんが、どのサプライチェーンを使うかをラベルで表現します。TAP では、ワークロードオブジェクトにつけられたラベルを見て、どのサプライチェーンが使われるかが決まります。ここではapps.tanzu.vmware.com/has-tests=true というラベルを付けていますが、これに対応するサプライチェーンが、この後確認するsource-test-scan-to-url になります。\nワークロードの状態を確認し、Ready になるまで数分待ちます。node-hello-tanzu よりもビルドに多少時間がかかります。\ntanzu apps workload get tanzu-java-web-app その間にサプライチェーンがどのような状態になっているか、TAP GUI を確認してみましょう。\nsource-to-url サプライチェーンと異なり、いくつか追加のステップがあることが分かります。今回はsource-test-scan-to-url サプライチェーンを使いましたが、これはTekton によるテストやGrype によるイメージスキャンが追加のステップとして定義されている組み込みのサプライチェーンになります。今回はTekton のテストは空ですが、当然カスタマイズすることができます。\n今回デプロイしたアプリケーションは脆弱性を多く含みますが、危険度が大きい脆弱性を検知した場合にデプロイを自動的に中止することができます（ワークショップの都合上、全ての脆弱性をこのサプライチェーンにおいては無視しました）。その後、ソースコードを編集し、対象の脆弱性を含むようなライブラリの利用を避ける、バージョンを上げるなどの対処をすることで、そのようなセキュリティリスクを含むアプリケーションが顧客に提供されることを防ぐことができます。\nアプリケーションの準備ができ、URL が発行されたらアクセスし、Greetings from Spring Boot + Tanzu! と表示されることを確認します。\n最後に、デプロイしたアプリケーションを削除します。\ntanzu apps workload delete tanzu-java-web-app -y "},{"id":7,"href":"/tap-workshop-docs/docs/module8/","title":"TAP のセキュリティ","section":"Docs","content":"\rTAP のセキュリティ\r#\rTAP のセキュリティとして「Shift Left」の発想を取り入りています。一言でいえばソフトウェア開発のなるべく早い段階でテストをしていくという考え方です。\nhttps://www.launchableinc.com/blog/shift-left-automated-tests-with-launchable/\n「セキュリティ = アンチウィルスソフト」のように、エージェントをインストールするようなイメージをもっている方も多いと思います。しかし、このアプローチですが、「いじめの問題を学校中に監視カメラを配置する」という解決策に似ています。以下のような問題が発生します。\n監視カメラの目が届かない場所がうまれるかもしれない セキュリティツールが万能でない可能性がある 監視カメラが学校生活を息苦しい場所にして転校が多くなるかもしれない 開発者がセキュリティ設定が緩やかな環境に逃げていく可能性がある 本質的ないじめ問題を解決していない 本質的なセキュリティ問題を解決していない このような背景から、セキュリティの問題を根本的に発生しにくくし、監視カメラもしくはエージェントすらいらないレベルまでセキュリティが当たり前に設定されている手法が重要になってきます。その上で開発生産性を落とさないアプローチとして、「 Shift Left 」のアプローチが注目されています。TAP では、セキュリティを開発の流れ、すなわち TAP のサプライチェーン に組み込んだ形で提供しています。\nこの サプライチェーン の過程ですが、主に、3つの機能で表現することができます。\nScan : TAP では、二段階のスキャンが実施されます。ソースコードそのもののスキャン、作成されたコンテナのスキャンの二段階で実施されます。二段階のスキャンにより、脆弱なコードが環境にデプロイされることを防ぎます。 Sign : イメージの署名を行います。厳格な環境の場合、署名を受けたイメージ以外のデプロイを防ぐといったことを実施します。 Store： Scan のフェーズでそのスキャニングの結果をデータベースに保管をして、高速な検索を実現します。 ここから、この機能について紐解いていこうと思います。なお、順番は Scan \u0026gt; Store \u0026gt; Sign の順に紹介します。 Sign (イメージの署名)\r#\rKubernetes では当たり前ですが、コンテナのフォーマットに従っていれば、なんでも起動ができてしまいます。ところが、セキュリティを考えた場合、 TAP の SupplyChain のプロセス以外で作成されるイメージを許可しないなどの制限を設ける必要性がでてきます。この「 TAP の SupplyChain のプロセス以外で作成されるイメージ」の判別の方法として使われるのが、イメージの署名、Sign 機能です。TAP では、 OSS である cosign を使った署名機能を使います。\ncosign 自体は基本的な機能は以下の Gif で紹介されていますが、秘密鍵によるイメージの署名、そして公開鍵によるイメージの認証をおこなうというシンプルなものです。\n今回のワークショップ環境は単一クラスタ構成ですが、TAP ではマルチクラスタ構成をとることができます。例えば、\nTAP をビルドクラスタ、Staging クラスタ、Production クラスタといった形でコンポーネントを分散させる ビルドクラスタの役目は TAP を使いセキュアなイメージをつくること ビルドクラスタに秘密鍵を登録して、イメージの署名 実際のワークロードは Staging クラスタ、Production クラスタにて稼働 Staging クラスタ、Production クラスタには公開鍵を登録して、認証以外のイメージを許容しないようにする Store (SBoM の活用)\r#\rScan 機能で脆弱性の検査が行われますが、その検索結果は SBoM (Software Bills of Materials)の形で metadata store とよばれるデータベースに保管されます。SBoM とは、パッケージの情報やバージョンをまとめたメタ情報です。通常の脆弱性検査に比べて、メタ情報のみの検索を行うため非常に高速に脆弱性検査ができることがメリットです。この「高速」は環境が小さい時こそ恩恵は感じにくいですが、環境が大きくなっていくにつれて、脆弱検査のスピードが重要になっていきます。\nTAP では専用の CLI である insight コマンドもしくは API を直接使い metadata store に保管された SBoM の検索が行えます。ここでの SBoM は先ほど紹介された Grype によって生成されています。以下 TAP によって作成されたイメージの検索結果ですが、そのイメージに含まれるパッケージ、バージョン、それにともなった脆弱性の照合までを瞬時で結果として得られます。metadata store を「脆弱性が報告された時に該当するイメージを瞬時にリストをしていく」などの機能ができるようになり、すばやく対応につなげていくことができます。\n参考までに、先ほどデプロイしたtanzu-java-web-app のSBoM を確認してみます。これらのコマンドはワークショップ環境では利用することができませんので、下記出力は参考としてご確認ください。\n今回ビルドしたコンテナイメージのダイジェストをもとに、tanzu insight コマンドでSBoM を表示させてみます。\n[root@localhost tap2]# tanzu insight image get --digest sha256:6cd706255927f6e27d73df4a857c2e499a76725511889db9071d38aa14a5663d\rID: 8\rRegistry: $REPO-URL\rImage Name: tap-workshop/supply-chain/tanzu-java-web-app-tap-workshop-01\rDigest: sha256:6cd706255927f6e27d73df4a857c2e499a76725511889db9071d38aa14a5663d\rPackages:\r1. helper@3.4.0\r2. HdrHistogram@2.1.12\r3. LatencyUtils@2.0.3\r4. jackson-annotations@2.13.4\r5. jackson-core@2.13.4\r6. jackson-databind@2.13.4.2\r7. jackson-datatype-jdk8@2.13.4\r8. jackson-datatype-jsr310@2.13.4\r9. jackson-module-parameter-names@2.13.4\r10. jakarta.annotation-api@1.3.5\r11. jul-to-slf4j@1.7.36\r12. log4j-api@2.17.2\r13. log4j-to-slf4j@2.17.2\r14. logback-classic@1.2.11\r15. micrometer-core@1.9.5\r16. tomcat-embed-el@9.0.68\r17. tomcat-embed-websocket@9.0.68\r18. Spring Cloud Bindings@1.10.0\r19. adduser@3.116ubuntu1\r20. helper@9.8.0\r21. BellSoft Liberica JRE@11.0.16\r22. apt@1.6.14\r23. base-files@10.1ubuntu2.11\r24. base-passwd@3.5.44\r25. bash@4.4.18-2ubuntu1.3\rCVEs:\r1. CVE-2022-3715 (Medium)\r26. bsdutils@1:2.31.1-0.4ubuntu3.7\r27. bzip2@1.0.6-8.1ubuntu0.2\r28. ca-certificates@20211016~18.04.1\r29. coreutils@8.28-1ubuntu1\rCVEs:\r1. CVE-2016-2781 (Low)\r30. dash@0.5.8-2.10\r31. debconf@1.5.66ubuntu1\r32. debianutils@4.8.4\r33. diffutils@1:3.6-1\r34. dpkg@1.19.0.5ubuntu2.4\r35. e2fsprogs@1.44.1-1ubuntu1.4\r36. fdisk@2.31.1-0.4ubuntu3.7\r37. findutils@4.6.0+git+20170828-2\r38. gcc-8-base@8.4.0-1ubuntu1~18.04\rCVEs:\r1. CVE-2020-13844 (Medium)\r39. gpgv@2.2.4-1ubuntu1.6\rCVEs:\r1. CVE-2022-3219 (Low)\r40. grep@3.1-2build1\r41. gzip@1.6-5ubuntu1.2\r42. hostname@3.20\r43. init-system-helpers@1.51\r44. libacl1@2.2.52-3build1\r45. libapt-pkg5.0@1.6.14\r46. libattr1@1:2.4.47-2build1\r47. libaudit-common@1:2.8.2-1ubuntu1.1\r48. libaudit1@1:2.8.2-1ubuntu1.1\r49. libblkid1@2.31.1-0.4ubuntu3.7\r50. libbz2-1.0@1.0.6-8.1ubuntu0.2\r51. libc-bin@2.27-3ubuntu1.6\rCVEs:\r1. CVE-2009-5155 (Low)\r2. CVE-2015-8985 (Low)\r3. CVE-2016-20013 (Low)\r52. libc6@2.27-3ubuntu1.6\rCVEs:\r1. CVE-2009-5155 (Low)\r2. CVE-2015-8985 (Low)\r3. CVE-2016-20013 (Low)\r53. libcap-ng0@0.7.7-3.1\r54. libcom-err2@1.44.1-1ubuntu1.4\r55. libdb5.3@5.3.28-13.1ubuntu1.1\r56. libdebconfclient0@0.213ubuntu1\r57. libexpat1@2.2.5-3ubuntu0.7\rCVEs:\r1. CVE-2022-40674 (Medium)\r2. CVE-2022-43680 (Medium)\r58. libext2fs2@1.44.1-1ubuntu1.4\r59. libfdisk1@2.31.1-0.4ubuntu3.7\r60. libffi6@3.2.1-8\r61. libgcc1@1:8.4.0-1ubuntu1~18.04\rCVEs:\r1. CVE-2020-13844 (Medium)\r62. libgcrypt20@1.8.1-4ubuntu1.3\r63. libgmp10@2:6.1.2+dfsg-2\rCVEs:\r1. CVE-2021-43618 (Low)\r64. libgnutls30@3.5.18-1ubuntu1.6\r65. libgpg-error0@1.27-6\r66. libhogweed4@3.4.1-0ubuntu0.18.04.1\r67. libidn2-0@2.0.4-1.1ubuntu0.2\r68. liblz4-1@0.0~r131-2ubuntu3.1\r69. liblzma5@5.2.2-1.3ubuntu0.1\r70. libmount1@2.31.1-0.4ubuntu3.7\r71. logback-core@1.2.11\r72. slf4j-api@1.7.36\r73. snakeyaml@1.32\rCVEs:\r1. GHSA-w37g-rhq8-7m4j (Medium)\r74. spring-aop@5.3.23\r75. spring-beans@5.3.23\r76. spring-boot@2.7.5\r77. spring-boot-actuator@2.7.5\r78. spring-boot-actuator-autoconfigure@2.7.5\r79. spring-boot-autoconfigure@2.7.5\r80. spring-boot-devtools@2.7.5\r81. spring-boot-jarmode-layertools@2.7.5\r82. spring-context@5.3.23\r83. spring-core@5.3.23\rCVEs:\r1. CVE-2016-1000027 (Critical)\r84. spring-expression@5.3.23\r85. spring-jcl@5.3.23\r86. spring-web@5.3.23\r87. spring-webmvc@5.3.23\r88. tomcat-embed-core@9.0.68\r89. helper@5.19.0\r90. libncurses5@6.1-1ubuntu1.18.04\rCVEs:\r1. CVE-2019-17594 (Low)\r2. CVE-2019-17595 (Low)\r3. CVE-2021-39537 (Low)\r4. CVE-2022-29458 (Low)\r91. libncursesw5@6.1-1ubuntu1.18.04\rCVEs:\r1. CVE-2019-17594 (Low)\r2. CVE-2019-17595 (Low)\r3. CVE-2021-39537 (Low)\r4. CVE-2022-29458 (Low)\r92. libnettle6@3.4.1-0ubuntu0.18.04.1\r93. libp11-kit0@0.23.9-2ubuntu0.1\r94. libpam-modules@1.1.8-3.6ubuntu2.18.04.3\r95. libpam-modules-bin@1.1.8-3.6ubuntu2.18.04.3\r96. libpam-runtime@1.1.8-3.6ubuntu2.18.04.3\r97. libpam0g@1.1.8-3.6ubuntu2.18.04.3\r98. libpcre3@2:8.39-9ubuntu0.1\rCVEs:\r1. CVE-2017-11164 (Low)\r99. libprocps6@2:3.3.12-3ubuntu1.2\r100. libseccomp2@2.5.1-1ubuntu1~18.04.2\r101. libselinux1@2.7-2build2\r102. libsemanage-common@2.7-2build2\r103. libsemanage1@2.7-2build2\r104. libsepol1@2.7-1ubuntu0.1\r105. libsmartcols1@2.31.1-0.4ubuntu3.7\r106. libss2@1.44.1-1ubuntu1.4\r107. libssl1.1@1.1.1-1ubuntu2.1~18.04.20\r108. libstdc++6@8.4.0-1ubuntu1~18.04\rCVEs:\r1. CVE-2020-13844 (Medium)\r109. libsystemd0@237-3ubuntu10.53\rCVEs:\r1. CVE-2022-2526 (Medium)\r2. CVE-2022-3821 (Medium)\r110. util-linux@2.31.1-0.4ubuntu3.7\r111. zlib1g@1:1.2.11.dfsg-0ubuntu2.2\rCVEs:\r1. CVE-2022-42800 (Medium)\r112. github.com/BurntSushi/toml@v1.1.0\r113. github.com/BurntSushi/toml@v1.2.0\r114. github.com/Masterminds/semver/v3@v3.1.1\r115. github.com/apex/log@v1.9.0\r116. github.com/buildpacks/libcnb@v1.27.0\r117. github.com/buildpacks/lifecycle@v0.0.0-20221021172422-4659c442e411\r118. github.com/creack/pty@v1.1.18\r119. github.com/h2non/filetype@v1.1.3\r120. github.com/heroku/color@v0.0.6\r121. github.com/imdario/mergo@v0.3.13\r122. github.com/magiconair/properties@v1.8.6\r123. github.com/mattn/go-colorable@v0.1.13\r124. github.com/mattn/go-isatty@v0.0.16\r125. sysvinit-utils@2.88dsf-59.10ubuntu1\r126. tar@1.29b-2ubuntu0.3\r127. tzdata@2022c-0ubuntu0.18.04.0\r128. ubuntu-keyring@2018.09.18.1~18.04.2\r129. libtasn1-6@4.13-2\r130. libtinfo5@6.1-1ubuntu1.18.04\rCVEs:\r1. CVE-2019-17594 (Low)\r2. CVE-2019-17595 (Low)\r3. CVE-2021-39537 (Low)\r4. CVE-2022-29458 (Low)\r131. libudev1@237-3ubuntu10.53\rCVEs:\r1. CVE-2022-2526 (Medium)\r2. CVE-2022-3821 (Medium)\r132. libunistring2@0.9.9-0ubuntu2\r133. libuuid1@2.31.1-0.4ubuntu3.7\r134. libyaml-0-2@0.1.7-2ubuntu3\r135. libzstd1@1.3.3+dfsg-2ubuntu1.2\r136. locales@2.27-3ubuntu1.6\rCVEs:\r1. CVE-2009-5155 (Low)\r2. CVE-2015-8985 (Low)\r3. CVE-2016-20013 (Low)\r137. login@1:4.5-1ubuntu2.3\rCVEs:\r1. CVE-2013-4235 (Low)\r138. lsb-base@9.20170808ubuntu1\r139. mawk@1.3.3-17ubuntu3\r140. mount@2.31.1-0.4ubuntu3.7\r141. ncurses-base@6.1-1ubuntu1.18.04\rCVEs:\r1. CVE-2019-17594 (Low)\r2. CVE-2019-17595 (Low)\r3. CVE-2021-39537 (Low)\r4. CVE-2022-29458 (Low)\r142. ncurses-bin@6.1-1ubuntu1.18.04\rCVEs:\r1. CVE-2019-17594 (Low)\r2. CVE-2019-17595 (Low)\r3. CVE-2021-39537 (Low)\r4. CVE-2022-29458 (Low)\r143. netbase@5.4\r144. openssl@1.1.1-1ubuntu2.1~18.04.20\r145. passwd@1:4.5-1ubuntu2.3\rCVEs:\r1. CVE-2013-4235 (Low)\r146. perl-base@5.26.1-6ubuntu0.5\rCVEs:\r1. CVE-2020-16156 (Medium)\r147. procps@2:3.3.12-3ubuntu1.2\r148. sed@4.4-2\r149. sensible-utils@0.0.12\r150. github.com/mattn/go-shellwords@v1.0.12\r151. github.com/miekg/dns@v1.1.50\r152. github.com/mitchellh/hashstructure/v2@v2.0.2\r153. github.com/onsi/gomega@v1.20.2\r154. github.com/paketo-buildpacks/ca-certificates/v3@v0.0.0-20220901010128-3944830c68f6\r155. github.com/paketo-buildpacks/libjvm@v1.40.0\r156. github.com/paketo-buildpacks/libpak@v1.62.0\r157. github.com/paketo-buildpacks/libpak@v1.63.0\r158. github.com/paketo-buildpacks/spring-boot/v5@v0.0.0-20220921103437-77d00b359dfa\r159. github.com/pavlo-v-chernykh/keystore-go/v4@v4.4.0\r160. github.com/pelletier/go-toml@v1.9.5\r161. github.com/pkg/errors@v0.9.1\r162. github.com/xi2/xz@v0.0.0-20171230120015-48954b6210f8\r163. golang.org/x/net@v0.0.0-20220923203811-8be639271d50\r164. golang.org/x/sys@v0.0.0-20220829200755-d48e67d00261\r165. golang.org/x/sys@v0.0.0-20220915200043-7b5979e65e41\r166. golang.org/x/sys@v0.0.0-20220919091848-fb04ddd9f9c8\r167. golang.org/x/sys@v0.1.0\r168. jrt-fs@11.0.16.1\r169. spring-cloud-bindings@1.10.0 また、 特定の CVE によって影響を受ける依存関係を表示させることもできます。2021 年12 月に公開された脆弱性「Log4Shell」はまだ記憶に新しいところではありますが、あまりに色々なソフトウェアにあたり前に利用されていたため、その影響範囲を調べることが困難でした。SBoM はソフトウェアがどのような材料で作られているかを示す表のようなものですので、脆弱性が発生したときにその影響範囲を明確にし、より適切な対応を取ることができる指針として活用できます。\n[root@localhost tap2]# tanzu insight vulnerabilities get --cveid CVE-2022-3821\r1. CVE-2022-3821 (Medium)\rPackages:\r1. libsystemd0@237-3ubuntu10.53\r2. libudev1@237-3ubuntu10.53 "},{"id":8,"href":"/tap-workshop-docs/docs/module9/","title":"まとめ","section":"Docs","content":"\rまとめ\r#\r本ワークショップでは、下記を学習しました。\nTAP の概要 Application Accelerator Live Update Git を使ったアプリケーションのデプロイ ソフトウェアサプライチェーン セキュアなソフトウェアサプライチェーン TAP のセキュリティ 以上で本ワークショップは終了です。お疲れ様でした。Code Server タブはそのまま閉じて構いません。\nTanzu Application Platform は、Application Accelerator、Learning Center、Tanzu Application Platform GUI、コンテナイメージの脆弱性スキャンを統合したサプライチェーンが含まれるソフトウェアサブスクリプションです。Tanzu Application Platform に興味を持たれた方はVMware の各担当営業までご連絡ください。\n"}]