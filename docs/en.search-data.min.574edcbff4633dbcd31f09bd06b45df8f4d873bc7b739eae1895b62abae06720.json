[{"id":0,"href":"/tap-workshop-docs/docs/module1/","title":"ワークショップ環境","section":"Docs","content":"\rワークショップ環境の概要\r#\r本ワークショップではCode Server と呼ばれるWeb サービスとし提供されるVS Code 環境を利用します。アクセスURL とパスワードに関しては講師からお伝えします。\nワークショップを提供する環境は以下のようになっています。 TAP は既にインストール済みなので、ワークショップ参加者がTAP のインストールや構成変更をする必要はありません。参加者ごとに提供されるCode Server と名前空間の中でアプリケーションのビルドやデプロイを実施します。\nCode Server の使い方\r#\rユーザーは本マニュアルに沿ってCode Server 上で提供されるエディタ機能やターミナルを用いてラボを進めます。\n本マニュアルの使い方\r#\rマニュアルと講師の指示通り操作します。ターミナルでの操作は下記のように表現しています。右上の📋（コピーボタン）をクリックすれば、クリップボードにコマンドをコピーできます。試しにやってみましょう。\nls {{/* TODO 要確認 */}} コマンドの貼り付けはCtrl+V キーで行います。Code Server の\u0026quot;ターミナル\u0026quot;では右クリックが許可されていないことに注意してください。\n一方で、単なるログの共有等には下記のような書き方をしていることに注意してください（コピーボタン📋はありません）。この場合はコマンドではないのでターミナルで入力する必要はないです。\n補足情報を書きます。\r注意が必要な情報を書きます。\rラボの進行に影響があるなど、重要な情報を書きます。\r解答\r解答です。\r"},{"id":1,"href":"/tap-workshop-docs/docs/module2/","title":"TAP 概要","section":"Docs","content":"\rTAP が求められる背景\r#\rKubernetes（K8s） はすでに世界中で利用されており、そのユーザー数は毎年どんどん増えています。日本においてもそのユーザー数は拡大しており、単なる検証フェーズではなく、本番環境での利用を進めているユーザーも増えています。それほど多くのユーザーがどんどん流入しているのは K8s 及びコンテナが有用だからなのですが、本格的に使い始めてから多くのユーザーが「K8s は難しい」という印象を抱きます。\n以下の図を見てください。 この図では K8s を比較的最近使い始めた入門ユーザーのアプリ開発からデプロイの流れ（上）と、エンタープライズ利用でのアプリ開発からデプロイまでの流れ（下）を記載しています。簡単に言ってしまうと、最初に K8s を使う場合は「アプリが動けばOK」で考えてしまうのですが、実際に大事なアプリを展開するには「バグったアプリにしない」「セキュリティ要件を満たす」「デプロイに失敗させない」などといった懸念事項が山のように出てきて、それを満たすための必要なアクションやツールがどんどん増えていきます。これは K8s 特有というよりも、従来の VM ベースの開発/運用のときと同じです。\nこの状況は K8s を使い始めた全ての組織が向き合う話ですので、これらを解決するためのツールや導入手順などが K8s の管理団体である CNCF を中心として存在しています。これらはいわゆる「Kubernetes エコシステム」と呼ばれるものです。どういったツールがあるかは「CNCF Cloud Native Interactive Landscape」にまとめられてあり、圧倒されるほどのプロジェクト数が存在しています。そして、それらを導入する手順の手引書として「CNCF Trail Map」が公開されており、かなり長い道のりが提示されています。\nこれらの道具を使って K8s の開発/運用の流れを構築するのですが、その作業も毎回人力で kubectl コマンドなどを叩くのではなく、自動化などのソリューションを利用するのが一般的です。この自動化のレベルも何段階かあり、おおよそ以下の図のレベル感となります。\n図の左が初期段階で、右に行くほど成熟してきます。一番左が自動化を全く使わずに毎回手動でコンテナをビルドして、デプロイ作業をするという段階です。K8s の基礎を学ぶだけでなく、自動化がカバーできない、たまに実施する操作や例外的な作業はマニュアルで実施します。ただ、先ほど紹介したエンタープライズな開発からデプロイまでを全てコマンドの手打ちで実施すると、面倒ですし操作ミスによるトラブルなども発生します。なにより、K8s を適切に理解している人しか、開発からデプロイまでの作業をできなくなってしまいます。\nその次のレベルがパイプラインの導入です。図にある Jenkins などが有名ですが、マニュアルで実施していた人間の作業をそのままパイプラインのスクリプトに落とし込むことで、人間が手を動かさなくても人間相当のことをパイプラインが愚直に実施してくれます。これはマニュアル作業で K8s の開発からデプロイまでを実施できるひとが、深い知識なしに手順を自動化できるという強みがあります。なぜなら、人間が打っていたコマンドラインを単にスクリプト化すればよいだけだからです。開発するアプリやパイプラインの環境が少ない場合はこれでよいかもしれません。ただ、K8s を本格的に導入しはじめると「数十のアプリを数十のパイプラインで自動化する」といった状況になってきます。こういった状況で原始的な手順ベースのパイプラインを作ってしまうと、各パイプラインの維持メンテナンスコストに悩まされます。\nそういったマニュアル作業や依存性の問題が辛くなってきたユーザーは、汎用パイプラインを卒業して多くの場合は K8s フレンドリーなツール群を使い始めます。有名なものは図にある Tekton や ArgoCD などです。たとえば Tekton によるビルドは K8s 方式の YAML 定義で実現できますし、ArgoCD によるデプロイは同様に Git リポジトリ上にある YAML 定義の構成ファイルに勝手に K8s クラスタをシンクさせるといった動きをします。Jenkins で人間の操作を自動化にそのまま落とし込むとパイプラインがフルオーダーメイドで調整しにくくなる一方、TektonやArgoCDなどはパラメーターをちょっと変更するセミオーダーメイドなので導入が簡単です。K8s のパワーユーザーはこういったツールを他にも大量に組み合わせてパイプラインを作ることが多いです。ただ、この方式にも問題があります。それは、「1つ1つの道具としては優秀なものの、それらを人間が手組みで組み合わせるという作業に辛さを覚える」という問題です。NHKの有名な教育番組のピタゴラスイッチというものがありますが、ちょうどあれを作るかのような感覚でパイプラインを組むようなものです。\nそういったユーザーが最後にたどり着くのが K8s のパイプラインフレームワークであり、VMware 製品ではこの記事で紹介する Tanzu Application Platform （TAP）となります。パイプラインフレームワークはパイプラインを構築しやすくするための仕組みであり、TAP の場合はまるでレゴでパイプラインを組み立てるかのように「フレームワークに道具を簡単にはめこめる」「道具は変更可能」ということを実現しています。こうすることで、手で調整するピタゴラスイッチなパイプラインから、ミニ四駆のような規格化されたパーツを目的に沿って組み合わせる形のパイプラインを構築できるようになります。\nTAPを導入することで、開発者はプラットフォームの些末なことを気にする必要がなくなり、アプリケーションの本質に注力することができるようになります。そして、インフラエンジニアは、開発者に対してよりよいプラットフォームを提供することを、1から100まで全て自分たちで手配する必要がなくなり、その大部分を TAP に任せることができるようになります。\nTAP の特徴\r#\rTAP の目指す世界感をおおまかにお伝えしたので、次はそれをどのように実現するかという具体的な話に移りたいと思います。まず、前提知識の話となりますが、開発者と運用者の生産性を高めるには、コンテナにしろレガシーなプラットフォームにしろ、以下のような開発/運用形態をとることが必要です。\n先にお伝えしたように、エンタープライズでのアプリケーション開発/運用は動けばよいというものではなく、セキュリティなど様々な考慮事項があり、それらの課題をクリアする必要があります。ただ、それらの課題全てを開発者が意識して開発するとなると、それはコードを書くことが本業の開発者にたいして多くを求めすぎているかもしれません。そのようなことを求めると一部の超優秀な開発者を除く8割の普通の開発者はついていけなくなります。 そういった状態になることを防ぐために、「開発者は深いことを考えずにコードを書くことに集中できる」ことと「運用者は開発者が開発したコードを、エンタープライズな要件を満たすかチェックし、満たせていれば運用に移り、満たせていなければ開発者に問題箇所を教える」ということを両立しなければいけません。このような「簡単さ」と「慎重さ」は相反するように思えるかもしれませんが、それは上記図のように**Inner Loop （開発者が効率よくコードを書ける仕組み）とOuter Loop（運用者が安全にシステムを運用できる仕組み）**の2本立てにすることで解決可能です。\nInner Loop は開発者本来の仕事を助けるために、「コードを書く。ビルドする。テストする」ということを短いサイクルで実現するための仕組みを提供します。コードにバグが含まれている場合などは、この短いサイクルでの開発と確認により、すでに問題箇所を特定して修復することが容易となります。\n一方、Outer Loop はさきほどのエンタープライズなパイプラインを実現するための仕組みを提供します。開発者が開発したコードが、ただ動くだけではなく、きちんとセキュリティなどの要件を満たせているかチェックし、満たせている場合は「本番環境で動いているアプリの置き換え」という一般的には重要で難しい対応をなんなく実現するための手法を提供します。\nTAPの場合は、この Inner Loop と Outer Loop を以下の図のような流れで支援しています。\nそして、この支援の裏側には以下の図のような様々なカテゴリに属するツール群が用意されています。\n本来はこれらのツール群は、k8s ユーザー自身が OSS として調達し、それらを組み合わせて目的を達成する必要があります。ただ、そのようなことを実現しようと思うと、膨大な数の検証と、アップグレードの際にちゃんと動くかテストをするといった作業負担が非常に大きいです。ただ、TAP の場合はそれらの作業を VMware がお客様の代わりに実施してあり、「このツールをフレームワークに沿って使えば動きます」という当たり前なものの実現することがなかなか大変な要件をいとも簡単に達成することができます。\nさて、実際にTAP は開発者や運用者をどのように支援できるのでしょうか？TAP の提供する機能とは具体的にどのようなものなのでしょうか？\n本ワークショップを通して、TAP を使って実際にアプリケーションの開発を体験してみることで、それらの強力な機能を学んでいきましょう！\n"},{"id":2,"href":"/tap-workshop-docs/docs/module3/","title":"Application Accelerator","section":"Docs","content":"\rApplication Accelerator\r#\r今回は、アプリケーション開発者である Taro のストーリーを基にラボを進めます。彼の会社では現在 Tanzu Application Platform が稼働しており、Taro はこのプラットフォームを使ってコンテナ化したアプリケーションの配信をしたいと考えています。\nTaro は、コンテナインフラストラクチャの専門家ではありません。あくまで開発者であり、人気のある言語やフレームワークを使ってビジネスアプリケーションを書くことに関しての専門家です。\nTaro は、開発プロジェクトを容易に始めるためのテンプレートを必要としています。彼は、開発プロジェクトの編集やビルド、実行に必要なすべてのコンポーネントを含む、厳選されたテンプレートをダウンロードしたいと思っています。そのようなテンプレートがあればオンボーディングがシンプルだからです。\nまた、Taro はDockerfile、Kubernetesリソース、およびその他のインフラストラクチャのアーティファクトを自分で記述し、維持する責任をなるべく負いたくありません。このようなインフラストラクチャの準備や運用によって、開発者はアプリケーションロジックを書いたり、ストーリーを提供したりする時間が少なくなってしまいます。\nこのような開発者の要望に対して、Tanzu Application Platform では、Taro が会社で使用が承認されたテンプレートを閲覧し、利用するための簡単な方法を提供します。これは Application Accelerator と呼ばれ、Tanzu Application Platform の Web インターフェース（TAP GUI）でホストされています。\nエンタープライズアーキテクトはApplication Accelerator を使って、組織内の開発者にコードや設定のためのエンタープライズに準拠したテンプレートを提供します。開発者はApplication Accelerator を使用して、企業標準に準拠したプロジェクトを作成したり、それにアクセスしたりできます。\nさて、さっそくApplication Accelerator を確認してみましょう。 TAPGUI のURL は下記コマンドで確認することができます。新しいブラウザタブを開いてTAP GUIにアクセスします。\necho $TAP_GUI_URL これで、Taro は自分が取り組みたいプログラミング言語(Java やNodeなど)とアプリケーションの種類（Web, メッセージ駆動型, 関数など）に適したテンプレートを見つけることができます。\nAccelerator Templates\r#\rTanzu Java Web App テンプレートで作業してみましょう。Spring Sensors のタイルにある choose ボタンを押します。UI でプロジェクトテンプレートをカスタマイズするためのオプションパラメータが提供されていますが、デフォルトのままNextを押してください。選択した内容を確認するプロンプトが表示されるので、Generate Acceleratorをクリックします。\nApplication Accelerator がプロジェクトテンプレートを作成し、テンプレートのブラウズまたはダウンロードのオプションが表示されます。\u0026ldquo;Explore Zip File \u0026ldquo;をクリックして、テンプレートを閲覧してみましょう。\nExplore Project ビューでファイルを見てみると、Java やSpring を知っている方であればおなじみのディレクトリ構造を確認できます。Taro がスターターアプリケーションで使用するソースコードファイルと、Tanzu Application Platform でアプリケーションを操作するためのいくつかの追加のファイルで構成されていることがわかります。これらの追加ファイルについては後のセクションで詳しく見ていきます。\nこのテンプレートはtanzu CLI でもダウンロードできます。\rここではこのテンプレートは使用しないので、ファイルをダウンロードする必要はありません。\r"},{"id":3,"href":"/tap-workshop-docs/docs/module4/","title":"Live Update","section":"Docs","content":"\rLive Update\r#\rApplication Accelerator では、Web UI を使用して、プロジェクトテンプレートを .zip ファイルとしてローカルマシンにダウンロードすることができます。今回は、このようなテンプレートがgit 上でホストされているケースを想定し、皆さんがおなじみのgit コマンドを使ってテンプレートをダウンロードし、アプリケーションの開発を開始します。\nさっそくテンプレートをダウンロードしましょう。\ngit clone https://github.com/vmjpsa/node-hello-tanzu.git cd node-hello-tanzu 今回はHello Tanzu! と画面に表示するだけの非常に単純なWeb アプリケーションで、アプリケーション開発を試してみます。\nTAP ではLive Update と呼ばれる便利な機能を提供しています。Live Update では、Tilt の機能を活用して、より高速な反復開発を実現することができます。フォルダの中にTiltfile_sample というファイルがあることに注目してください。Tiltfile は Application Accelerator によってプロジェクトテンプレートの一部として作られたファイルです。Tiltfile スクリプトは、Tanzu Application Platform を利用して、3つの主要なタスクを実行します。\nコンテナイメージの作成 アプリケーションの実行と、アプリケーションへアクセスするための Kubernetes リソースを作成 ソースコードの編集に伴うアプリケーションのLive Update を有効にする これらの各ステップを詳しく見ていきましょう。\nコンテナイメージの作成\r#\rTanzu Application Plaform の最も強力な機能の1つは、Tanzu Build Service です。これは開発者が提供するアプリケーションのソースコードからランタイムコンテナを自動生成します。これらのコンテナイメージを作成するために、CNCFプロジェクトのCloud Native Buildpacksを活用しています。Tanzu は、最新の言語ランタイムの依存性を提供しながら、セキュリティとパフォーマンスのためにコンテナイメージを最適化するためのビルドパックを提供します。Tanzu のビルドパックは、Java、.NET Core、Node、Go、Python、PHPなど、最も一般的なプログラミング言語に対応しています。また、その他の言語のニーズがある場合は、オープンソースコミュニティが他の多くの言語用のビルドパックを提供しています。\n開発者のTaro は、Tanzu Build Service のメリットを活用することで、自分で Dockerfile を作成したり、メンテナンスしたりする必要がなく、コンテナの安全性やパッチの適用を保証するための作業に追われることもなくなります。彼は、コンテナランタイムの生成ではなく、ソースコードを書く本来の作業に集中することができます。Tanzu Build Service の他の利点については後ほど見ていきます。\nKubernetes リソースの作成\r#\r開発環境が Kubernetes クラスタの場合、Tanzu Application Platform はコンテナイメージをデプロイ・実行するために必要な Kubernetes リソースを作成し、ローカルマシンから Kubernetes にデプロイされたアプリケーションにアクセスできるようにします。この環境では、Tanzu Application Platform に組み込まれているオープンソースプロジェクト Knative をランタイムに使用しています。\nLive Update\r#\rTilt では、開発環境にアプリケーションをデプロイするもので、初回実行時には完了まで数分かかりますが、次回以降の時間は短縮されるため、実行中のアプリケーションを数秒で更新することができます。どのように動作するか見てみましょう。\nまずは、自身の環境から、作成したコンテナイメージをプッシュできるようにコンテナレジストリにログインをします。\ndocker login $REPO_URL -u $REPO_USER -p $REPO_PASSWORD 次に、Tiltfile を作成します。先にみたように、本来Tiltfile はテンプレートに含むべきですが、このワークショップでは環境の都合上ユーザーごとにTiltfile を編集する必要があるため、下記コマンドで作成します。少し長い入力ですが、実行しているのはTiltfile_sample をベースとしたTiltfile の作成です。\ncat \u0026lt;\u0026lt;EOF \u0026gt; Tiltfile SOURCE_IMAGE = os.getenv(\u0026#34;SOURCE_IMAGE\u0026#34;, default=\u0026#39;${REPO_URL}/tap-workshop/node-hello-tanzu-${SESSION_NUMBER}\u0026#39;) # REPO_URL like harbor.tanzu.lab/tap-workshop/node-hello-tanzu LOCAL_PATH = os.getenv(\u0026#34;LOCAL_PATH\u0026#34;, default=\u0026#39;.\u0026#39;) NAMESPACE = os.getenv(\u0026#34;NAMESPACE\u0026#34;, default=\u0026#39;\u0026#39;) K8S_TEST_CONTEXT = os.getenv(\u0026#34;K8S_TEST_CONTEXT\u0026#34;, default=\u0026#39;\u0026#39;) allow_k8s_contexts(K8S_TEST_CONTEXT) k8s_custom_deploy( \u0026#39;node-hello-tanzu\u0026#39;, apply_cmd=\u0026#34;tanzu apps workload apply -f config/workload.yaml --live-update\u0026#34; + \u0026#34; --local-path \u0026#34; + LOCAL_PATH + \u0026#34; --source-image \u0026#34; + SOURCE_IMAGE + \u0026#34; --namespace \u0026#34; + NAMESPACE + \u0026#34; --yes \u0026gt;/dev/null\u0026#34; + \u0026#34; \u0026amp;\u0026amp; kubectl get workload node-hello-tanzu --namespace \u0026#34; + NAMESPACE + \u0026#34; -o yaml\u0026#34;, delete_cmd=\u0026#34;tanzu apps workload delete -f config/workload.yaml --namespace \u0026#34; + NAMESPACE + \u0026#34; --yes\u0026#34; , deps=[\u0026#39;.\u0026#39;], container_selector=\u0026#39;workload\u0026#39;, live_update=[ fall_back_on([\u0026#39;package.json\u0026#39;]), sync(\u0026#39;.\u0026#39;, \u0026#39;/workspace\u0026#39;) ] ) k8s_resource(\u0026#39;node-hello-tanzu\u0026#39;, port_forwards=[\u0026#34;8080:8080\u0026#34;], extra_pod_selectors=[{\u0026#39;carto.run/workload-name\u0026#39;: \u0026#39;node-hello-tanzu\u0026#39;, \u0026#39;app.kubernetes.io/component\u0026#39;: \u0026#39;run\u0026#39;}]) allow_k8s_contexts(\u0026#39;${CLUSTER_NAME}\u0026#39;) EOF Tiltfile ができたら、いよいよLive Update の機能を試します。下記のtanzu コマンドを入力します。このコマンドではgit clone したローカルのファイルをベースにワークロードの作成の準備をします。\n{{/* TODO コマンド要確認 */}}\ntanzu apps workload apply node-hello-tanzu --live-update --local-path . -s $REPO_URL/tap-workshop/node-hello-tanzu-${SESSION_NUMBER} -y 下記のようなログが出力されるはずです。\nPublishing source in \u0026#34;.\u0026#34; to \u0026#34;$REPO_URL/tap-workshop/node-hello-tanzu-${SESSION_NUMBER}\u0026#34;...\rPublished source\rCreate workload:\r1 + |---\r2 + |apiVersion: carto.run/v1alpha1\r3 + |kind: Workload\r4 + |metadata:\r5 + | name: node-hello-tanzu\r6 + | namespace: tap-workshop-01\r7 + |spec:\r8 + | source:\r9 + | image: $REPO_URL/tap-workshop/node-hello-tanzu-${SESSION_NUMBER}:latest@sha256:abcdef... tanzu コマンド入力後、tilt up でワークロードがデプロイされます。コマンド入力後、s キーを入力してアプリケーションのデプロイまでのログを確認します。\ntilt up ログは下記のように出力されます。先述したように、初回のビルドは少し時間がかかります。\ncoder@code-server-696f98d647-vx77m:~/node-hello-tanzu$ tilt up\rTilt started on http://localhost:10350/\rv0.30.11, built 2022-11-07\r(space) to open the browser\r(s) to stream logs (--stream=true)\r(t) to open legacy terminal mode (--legacy=true)\r(ctrl-c) to exit\rTilt started on http://localhost:10350/\rv0.30.11, built 2022-11-07\rInitial Build\rLoading Tiltfile at: /home/coder/node-hello-tanzu/Tiltfile\rSuccessfully loaded Tiltfile (1.415443ms)\rERROR: [] \u0026#34;msg\u0026#34;=\u0026#34;Reconciler error\u0026#34; \u0026#34;error\u0026#34;=\u0026#34;Failed to update API server: create configmaps/node-hello-tanzu-disable: configmaps.tilt.dev \\\u0026#34;node-hello-tanzu-disable\\\u0026#34; already exists\u0026#34; \u0026#34;controller\u0026#34;=\u0026#34;tiltfile\u0026#34; \u0026#34;controllerGroup\u0026#34;=\u0026#34;tilt.dev\u0026#34; \u0026#34;controllerKind\u0026#34;=\u0026#34;Tiltfile\u0026#34; \u0026#34;Tiltfile\u0026#34;={\u0026#34;name\u0026#34;:\u0026#34;(Tiltfile)\u0026#34;} \u0026#34;namespace\u0026#34;=\u0026#34;\u0026#34; \u0026#34;name\u0026#34;=\u0026#34;(Tiltfile)\u0026#34; \u0026#34;reconcileID\u0026#34;=\u0026#34;caf681ca-5e03-4d6f-9e76-c6e0468da938\u0026#34;\rWARNING: Writing Kubernetes config: could not create any of the following paths: /run/user/1000/tilt-dev/tilt-default/cluster\rnode-hello-t… │ node-hello-t… │ Initial Build\rnode-hello-t… │ STEP 1/1 — Deploying\rnode-hello-t… │ Running cmd: tanzu apps workload apply -f config/workload.yaml --live-update --local-path . --source-image $REPO_URL/tap-workshop/node-hello-tanzu-01 --namespace tap-workshop-01 --yes \u0026gt;/dev/null \u0026amp;\u0026amp; kubectl get workload node-hello-tanzu --namespace tap-workshop-01 -o yaml\rnode-hello-t… │ Objects applied to cluster:\rnode-hello-t… │ → node-hello-tanzu:workload\rnode-hello-t… │ node-hello-t… │ Step 1 - 1.88s (Deploying)\rnode-hello-t… │ DONE IN: 1.88s node-hello-t… │ node-hello-t… │ node-hello-t… │ Tracking new pod rollout (node-hello-tanzu-00001-deployment-66df8f56b6-2bp5q):\rnode-hello-t… │ ┊ Scheduled - \u0026lt;1s\rnode-hello-t… │ ┊ Initialized - (…) Pending\rnode-hello-t… │ ┊ Ready - (…) Pending\rnode-hello-t… │ [queue-proxy] {\u0026#34;severity\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;timestamp\u0026#34;:\u0026#34;2022-12-05T11:37:01.427999526Z\u0026#34;,\u0026#34;logger\u0026#34;:\u0026#34;queueproxy\u0026#34;,\u0026#34;caller\u0026#34;:\u0026#34;queue/main.go:197\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Starting queue-proxy\u0026#34;,\u0026#34;commit\u0026#34;:\u0026#34;3666ce7\u0026#34;,\u0026#34;knative.dev/key\u0026#34;:\u0026#34;tap-workshop-01/node-hello-tanzu-00001\u0026#34;,\u0026#34;knative.dev/pod\u0026#34;:\u0026#34;node-hello-tanzu-00001-deployment-66df8f56b6-2bp5q\u0026#34;} デプロイが完了したら、アプリケーションにアクセスしてみましょう。アプリケーションは今Kubernetes 上にデプロイされていますが、下記スクリーンショットのように、Code Server ポートフォワーディングの機能でローカル端末からアクセスできます。\n画像\r#\rCtrl + クリック、またはURL を直接コピーし、別タブでアクセスします。このタブは開いたままにします。\n次に、アプリケーションのコードの中心であるindex.js ファイルを開き、Hello Tanzu! をHello Tanzu!!! などと任意に変更してみてください。すると、tilt の出力が下記のように更新されるはずです。\n......\rnode-hello-t… │ 1 File Changed: [index.js]\rnode-hello-t… │ Will copy 1 file(s) to container: [node-hello-tanzu-00002-deployment-5ffd767b87-78m56/workload]\rnode-hello-t… │ - \u0026#39;/home/coder/node-hello-tanzu/index.js\u0026#39; --\u0026gt; \u0026#39;/workspace/index.js\u0026#39;\rnode-hello-t… │ → Container node-hello-tanzu-00002-deployment-5ffd767b87-78m56/workload updated! 再びアプリケーションのタブを確認し、画面を更新すると、上記の変更が即座に反映されているはずです。\n画像\r#\rターミナルにてCtrl+C を入力し、LiveUpdate を中断しましょう。\n今回は単純なNodeJS のアプリでしたが、例えばSpring （Java） のアプリ等でも同様な機能を利用することができます。この際、Dockerfile はどこにも登場しなかったことに注意してください。TAP のコンポーネントであるTanzu Build Service によって、自動的にNodeJS のアプリと判定され、ベストプラクティスに沿った形でコンテナ化され、それがKubernetes 上に展開されています。開発者としては、アプリケーションの本質的な部分により時間を割くことができます。\nまた、今回はLive Update を利用するためにtanzu とtilt の2 つのコマンドを使いましたが、TAP ではVS Code やIntelliJ といったエディタの拡張機能としてもLive Update の機能を提供しており、これらのコマンドを入力することなく利用することができます（今回はラボの制約のためCLI 入力としました）。\n画像\r#\r削除必要？？\r#\rこれでLive Update の機能を確認できました。最後に、ログでターミナルが汚れていると思いますので、確認し終わったらclear してしまいましょう。\nclear Tanzu コマンド ラインを使用して、最初のデプロイの準備ができたことを確認します。\ntanzu apps workload get spring-sensors これは、関連する Pod や Knative Services とともに、サプライチェーンを通じて進行するワークロードの状態を報告します。 デプロイの準備が完了すると、下部にこのような作業用の URL が表示されます。もし Knative Services の READY の欄に Ready と表示されない場合は、完了するまでコマンドを何度か繰り返して確認してください。\nKnative Services\rNAME READY URL\rspring-sensors Ready http://spring-sensors-tap-demos-w07-s003.tap.corby.cc ターミナルウィンドウで URL をクリックすると、アプリケーションが表示されます。\nReady になる前に次に進まないでください。\nでは、ここからはアプリケーションのコードを変更してみましょう。現在、バナーのテキストは「Spring Sensors」と表示されています。バナーを他のものに変更してみましょう。\nfile: spring-sensors/src/main/java/org/tanzu/demo/DemoController.java\rtext: \u0026#34;Spring Sensors\u0026#34; 選択したテキストは、コードエディタで入力して置き換えるか、以下をクリックして自動的に文字列の置換を適用することができます。\nfile: spring-sensors/src/main/java/org/tanzu/demo/DemoController.java\rtext: Hot New Banner このコード変更をすると、実行中のコンテナに自動的にパッチが適用されます。10秒以内にターミナルウィンドウでアプリケーションが再起動するのが確認できます。アプリケーションが動作しているブラウザのタブに移動して、リフレッシュしてください。 コードの変更が自動的に適用されていることがわかります。\nこれで、Cody は集中してコード開発を続けることができます。彼はコード変更を反映させる作業を都度することなく、次の機能のコーディングを開始し、実行中のコンテナですぐに段階的な結果を確認しながら開発を続けることができます。Live Update の詳細はドキュメントをご参照ください。\nでは、他に Tanzu Application Platform を使ってできる機能を引き続き見ていきましょう。\n"},{"id":4,"href":"/tap-workshop-docs/docs/module5/","title":"Live View","section":"Docs","content":"\rTODO node でどこまで見れるか、見られない場合は次の章に後回し Live View は現在、Spring Boot の Java アプリケーションと、Steeltoe .NET Core アプリケーションに対応しています。\r#\rLive View\r#\rアプリケーションをデプロイした後、そのアプリケーションが期待通りの動作をせず、診断やトラブルシューティングのためにアプリケーションのランタイムの動作に関する詳細な情報（例えば、アプリケーションのメモリが不足しているのか？ HTTP リクエストのレスポンスタイムはどうなっているのか？）が必要になることがあります。\nTanzu Application Platform は、Taro のような開発者がそういった情報を収集するのに役立つ Live View を提供しています。ここからは Live View の機能について見てみましょう。まずは TAP GUI （Web UI） にアクセスし、先ほど作成したアプリケーションを確認してみましょう。TAP GUI を再度開く必要がある場合は、下記コマンドでURL を調べることができます。\necho $TAP_GUI_URL 画像\r#\rここでは、私たちのアプリケーションであるnode-hello-tanzu のDeployment (Kubernetes リソース)を実行しています。複数のDeployment がリストアップされている可能性が高いです。これはマルチテナント開発環境では、異なる開発者 (または異なるワークショップセッション) がそれぞれコードのブランチに取り組んでいるためです。マルチテナント開発クラスタ (TAP では Iterate クラスタとも呼ばれます) では、各開発者は開発環境を分離するために各自のネームスペースで作業しています。\nあなたのセッションの名前空間は下記コマンドで確認できます（今回は全員同じアプリケーションをデプロイしているため、他のユーザーの名前空間を確認しても構いません）。\necho tap-workshop-$SESSION_NUMBER 次に、名前空間に対応する行のnode-hello-tanzu ハイパーリンクをクリックし、Kind 列のKnative Serviceという値をクリックします。これで、アプリの詳細ビューが表示されます。\n画像\r#\rこの画面を下にスクロールすると、アプリに関連する Kubernetes リソースが表示されます。画面の一番下には、Pod があります。Kubernetes では Pod はアプリケーションコンテナが実行される場所です。では、自分の Pod の名前をクリックしてみましょう。\n画像\r#\rPod の情報が見られる画面の上部には、詳細情報が見られる画面へのリンクがあり、プロセスに関する主要な情報に素早くアクセスできます。View Pod Logs をクリックすると、アプリが動作している Kubernetes サーバーのアプリケーションログを見ることができます。\n画像\r#\r少し下にスクロールすると、ライブビューペインが表示されます。ここには、Information Category というドロップダウンのメニューがあり、Application Runtime のあらゆるデータを閲覧することができます。\n画像\r#\rこれらのデータを好きに確認してみてください。ここには多くの見るべきものがあり、アプリケーションの環境変数のチェック、スレッドスタックトレースの表示、メモリ消費量のグラフ表示、各 HTTP リクエストのトレース情報など、様々な情報を見ることができます。\ntanzu workload apps delete node-hello-tanzu -y "},{"id":5,"href":"/tap-workshop-docs/docs/module6/","title":"サプライチェーン","section":"Docs","content":"\rソフトウェアサプライチェーン\r#\r先ほどLive Update でアプリケーションをデプロイしましたが、先述したようにコードを書いてURL として公開される、いわゆるSource to URL の世界のその間に実際に多くのプロセスが含まれます。それを確認してみましょう。\nTAP GUI を再度開いてください。URL は下記コマンドで確認できます・\necho $TAP_GUI_URL GUI ベースで確認\n画像\r#\rサプライチェーンとは？\r#\r先のモジュール2 でも少し触れましたが、TAP の中核となる概念はソフトウェアサプライチェーンです。少し分かりづらい表現のため、改めてここで説明します。\n企業のソフトウェア開発組織の管理者にとって、ソフトウェアのサプライチェーン、すなわちソフトウェアを「原材料」から「完成品」へと導く一連のソースおよびアクションという概念は、あまりに抽象的に感じられるかもしれません。この定義は本質的に正しくても、サプライチェーンがいかに既存の継続的インテグレーションと継続的デプロイメント（CI/CD）環境を補完するものであるかの説明には不十分です。\nソフトウェア開発プロセスのスピードと、そのプロセスを通過するアプリケーションの数が増加すると、アプリケーション チームとそのステークホルダー間で調整すべき内容も指数関数的に増加します。 しかし、ほとんどの CI/CD ツールは、一度に 1 つのアプリケーションを提供するプロセスを定義するように構築されています。（多くのお客様が社内にお持ちの）品質重視のリリース エンジニアリング チームに、各アプリケーション プロセスの詳細の管理において、開発者とのやり取りにどれくらい時間がかかっているのか聞いてみると良いでしょう。きっと、かなりの時間を費やしている、と答えるはずです。\n本番環境へのパスとは、ソフトウェア プロジェクトの構想段階から、ユーザー（消費者、患者、従業員など）に価値をもたらすまでのプロセスおよび活動全体を指します。今日これは、堅牢に相互連携された入力、アクション、リリース自動化という一連の作業により、テスト、セキュリティ検証、監査対応のガバナンス データの取得などを処理することを意味します。ビジネス オーナー、ゼネラル マネージャ、エンタープライズ アーキテクト、SRE、情報セキュリティ チームなどの誰もが、ソフトウェアがユーザーに安全かつ確実に届くまでのプロセスに関わるステークホルダーといえます。\nここで、現在の CI/CD ツールの「1 チームにつき 1 プロセス」という直線的で連続したアプローチには限界が出てきます。多くのプロセスを作成／実行することはできますが、一度に数百のプロセスを監視または変更するとなると、これらのツールは役に立ちません。\nさらに、ほとんどの大企業がマルチクラウドやハイブリッドクラウドのプラットフォーム モデルに移行しているという事実もあります。これにより、各開発チームが使用するツールやサービスにばらつきがあると、本番環境へのパスの全社的な管理はより難しくなります。 さまざまなプロセス定義、ツール、サービス、ポリシーの組み合わせによって、管理すべきシナリオは膨大な数になります。\nそこで、ソフトウェア サプライチェーンによるスケーラビリティの実現が必要になります。\nまず、マイクロサービスによって組織全体にサービスを提供できるようになり、本番環境へのパスに関わる各種チームはさらなる俊敏性を獲得できます。たとえば、セキュリティ チームはコードとイメージのスキャンをサービスとして提供できます。一方で運用チームは、アーキテクチャやコンプライアンス体制など異なるアプリケーション カテゴリの要件に合わせて調整されたデプロイ ツールを実行できます。このような各種サービスは、オープンソースのプロジェクト Cartographer や、TAP に含まれる商用版のサプライチェーン コレオグラファーなどを通じて調整できます。\n各チームは、利用するサプライチェーンのリファクタリングを一切必要とせず、必要に応じてサービスを更新できます。開発チームや運用チームはさまざまなツールから、特定のワークロードに最適なものを選択できるようになります。Linux のテキスト処理ツールがパイプを使って連結できるように、サプライチェーンもコンポーザブルになります。\n画像\r#\rこの図は、ここまで説明した多くの要素を組み合わせたサプライチェーンの一例です。ビルド プロセスには既存の Jenkins CI プロセスを使用すること、イメージ スキャンに対応するサプライチェーン オプションにはそれぞれ要求しきい値があること、プラットフォーム運用チームがサプライチェーン全体の流れを管理すること、開発者にはコード-イメージプロセスのコントロール権限が与えられること、セキュリティ運用チームが最終的なコードとイメージ スキャンに責任を持つことを確認してください。\n実際、これらのアプリケーション カテゴリでも、各アプリケーションに必要なカスタマイズが可能なベースライン サプライチェーンを持つことができます。同じサービスを使用しても、おそらくアプリケーションによっては追加のテストが実行されたり、別の承認プロセスが起動されたりします。\nこのように課題に応じた分離をサポートするため、VMware は Tanzu Application Platform にコンベンション サービスを搭載しています。コンベンションとは、基本的にサプライチェーンを通過する際にあらゆるアプリケーションに適用できる設定に対する注釈（アノテーション）です。したがって、すべての PCI 対応アプリケーションでネットワーキングに特定の Ingress ルールが求められる場合、セキュリティ チームは PCI アプリケーション用にあらゆるサプライチェーンで適用されるコンベンションを作成することができます。コンベンションはサプライチェーンから独立して管理されるため、バージョン管理および展開も独立して実施できます。\nコンベンションの詳細に関しては下記ブログを参照してください。\nhttps://blogs.vmware.com/vmware-japan/2022/03/tanzu-application-platform-covention-service.html\nこれらのメリットを享受するために、既存の CI/CD ツールを置き換える必要はありません。既存のプロセスを、サプライチェーンに含まれるサービスに変えることができます。また、サプライチェーンの残りの部分が実行される前に CI 出力に自動調整が適用されるため、その出力の正確性を自動で検証できます。既存の CD 自動化は適切なサプライチェーン条件が満たされたときにトリガーされ、検証済みのアプリケーションのみが確実に本番環境にデプロイされます。ほとんどのユーザーは既存のツールの統合を行ってから、他のサプライチェーン管理の比較した際に感じられるこの CI の強みを活かし、本番環境までのパスにおける各種要素を段階的に進化させていくでしょう。\nこれらすべてを組み合わせて構築された環境では、アプリケーションごとに各ステップをすり合わせる必要がなく、多くのアプリケーションの高度な開発が可能であり、拡張も容易です。このようなサプライチェーンの考え方と、それを実現するTAP のコンポーネントでありOSS であるCartographer のような仕組みは、変化に強い、堅牢で拡張性の高いCI/CD 環境を実現するために役に立つはずです。\n"},{"id":6,"href":"/tap-workshop-docs/docs/module7/","title":"サプライチェーン","section":"Docs","content":"\rLive Update\r#\r概要\n"},{"id":7,"href":"/tap-workshop-docs/docs/module8/","title":"セキュアなサプライチェーン","section":"Docs","content":"\rLive Update\r#\r概要\n"}]